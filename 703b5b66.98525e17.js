(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{107:function(e,t,n){"use strict";n.d(t,"a",(function(){return b})),n.d(t,"b",(function(){return h}));var r=n(0),a=n.n(r);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function p(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=a.a.createContext({}),s=function(e){var t=a.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):p(p({},t),e)),n},b=function(e){var t=s(e.components);return a.a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},m=a.a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),b=s(n),m=r,h=b["".concat(o,".").concat(m)]||b[m]||d[m]||i;return n?a.a.createElement(h,p(p({ref:t},l),{},{components:n})):a.a.createElement(h,p({ref:t},l))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=m;var p={};for(var c in t)hasOwnProperty.call(t,c)&&(p[c]=t[c]);p.originalType=e,p.mdxType="string"==typeof e?e:r,o[1]=p;for(var l=2;l<i;l++)o[l]=n[l];return a.a.createElement.apply(null,o)}return a.a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},85:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return p})),n.d(t,"toc",(function(){return c})),n.d(t,"default",(function(){return s}));var r=n(3),a=n(7),i=(n(0),n(107)),o={id:"filter-steps",title:"Filter Steps"},p={unversionedId:"cpgql/filter-steps",id:"cpgql/filter-steps",isDocsHomePage:!1,title:"Filter Steps",description:"Filter Steps are CPGQL Steps which filter nodes in a traversal according to a criterion. Joern supports four Generic Filter Steps which can be added to any other step, and number of specific filter steps called Property Filter Steps which can be used on nodes of a certain type.",source:"@site/docs/cpgql/filter-steps.mdx",slug:"/cpgql/filter-steps",permalink:"/cpgql/filter-steps",editUrl:"https://github.com/joernio/website/edit/master/docs.joern.io/docs/cpgql/filter-steps.mdx",version:"current",sidebar:"docs",previous:{title:"Node-Type Steps",permalink:"/cpgql/node-type-steps"},next:{title:"Core Steps",permalink:"/cpgql/core-steps"}},c=[{value:"Property Filter Steps",id:"property-filter-steps",children:[]},{value:"filter",id:"filter",children:[]},{value:"where",id:"where",children:[]},{value:"whereNot",id:"wherenot",children:[]}],l={toc:c};function s(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(i.b)("wrapper",Object(r.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"Filter Steps are CPGQL Steps which filter nodes in a traversal according to a criterion. Joern supports four ",Object(i.b)("em",{parentName:"p"},"Generic Filter Steps")," which can be added to any other step, and number of specific filter steps called ",Object(i.b)("em",{parentName:"p"},"Property Filter Steps")," which can be used on nodes of a certain type.\nThe ",Object(i.b)("em",{parentName:"p"},"Generic Filter Steps")," are ",Object(i.b)("inlineCode",{parentName:"p"},"filter"),", ",Object(i.b)("inlineCode",{parentName:"p"},"filterNot"),", ",Object(i.b)("inlineCode",{parentName:"p"},"where")," and ",Object(i.b)("inlineCode",{parentName:"p"},"whereNot"),". The ",Object(i.b)("em",{parentName:"p"},"Property Filter Steps")," for each node type correspond to the ",Object(i.b)("em",{parentName:"p"},"Property Directives")," it has defined."),Object(i.b)("p",null,"We will look at the behaviour of each of these steps while analyzing a simple program named ",Object(i.b)("inlineCode",{parentName:"p"},"X42"),":"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-c"}),'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(int argc, char *argv[]) {\n  if (argc > 1 && strcmp(argv[1], "42") == 0) {\n    fprintf(stderr, "It depends!\\n");\n    exit(42);\n  }\n  printf("What is the meaning of life?\\n");\n  exit(0);\n}\n')),Object(i.b)("h3",{id:"property-filter-steps"},"Property Filter Steps"),Object(i.b)("p",null,Object(i.b)("em",{parentName:"p"},"Property Filter Steps")," are ",Object(i.b)("em",{parentName:"p"},"Filter Steps")," which continue a traversal if the properties of the nodes they point to pass a certain criterion.\nFor example, to query the Code Property Graph for all CALL nodes which have the string ",Object(i.b)("inlineCode",{parentName:"p"},"exit")," as the value for their CODE property:"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-java"}),'joern> cpg.call.name("exit").code.l \nres0: List[String] = List("exit(0)", "exit(42)")\n')),Object(i.b)("p",null,"The criterion is unique to every ",Object(i.b)("em",{parentName:"p"},"Property Filter Step"),". In the case of the ",Object(i.b)("inlineCode",{parentName:"p"},"name")," ",Object(i.b)("em",{parentName:"p"},"Property Filter Step")," of the ",Object(i.b)("inlineCode",{parentName:"p"},"call")," ",Object(i.b)("em",{parentName:"p"},"Node-Type Step"),", its criterion is a string that represents a regular expression; that is, all following queries will deliver the same result for the ",Object(i.b)("inlineCode",{parentName:"p"},"X42")," program:"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-java"}),'joern> cpg.call.name("exit").code.l \nres0: List[String] = List("exit(0)", "exit(42)")\n\njoern> cpg.call.name("[eE]xit").code.l \nres1: List[String] = List("exit(0)", "exit(42)")\n\njoern> cpg.call.name("ex.*").code.l \nres2: List[String] = List("exit(0)", "exit(42)")\n')),Object(i.b)("p",null,"Just like all other ",Object(i.b)("em",{parentName:"p"},"Filter Steps"),", ",Object(i.b)("em",{parentName:"p"},"Property Filter Steps")," can be chained together:"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-java"}),'joern> cpg.call.name("exit").code(".*0.*").code.l \nres0: List[String] = List("exit(0)")\n')),Object(i.b)("p",null,"Unlike ",Object(i.b)("em",{parentName:"p"},"Property Directives"),", ",Object(i.b)("em",{parentName:"p"},"Property Filter Steps")," are usually greater in number than the properties defined on a node type. Most ",Object(i.b)("em",{parentName:"p"},"Property Filter Steps")," have their negated version available:"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-java"}),'joern> cpg.call.name("exit").codeNot(".*0.*").code.l \nres0: List[String] = List("exit(42)")\n')),Object(i.b)("h3",{id:"filter"},"filter"),Object(i.b)("p",null,"The ",Object(i.b)("inlineCode",{parentName:"p"},"filter")," ",Object(i.b)("em",{parentName:"p"},"Step")," is a ",Object(i.b)("em",{parentName:"p"},"Filter Step")," which continues a traversal for all nodes which pass its criterion. The criterion of the ",Object(i.b)("inlineCode",{parentName:"p"},"filter")," step is represented by an expression which has one argument, a variable that points to the node matched in the previous step, and which returns a boolean. For example, suppose you'd like to query the Code Property Graph of the ",Object(i.b)("inlineCode",{parentName:"p"},"X42")," program for all CALL nodes which have ",Object(i.b)("inlineCode",{parentName:"p"},"exit")," as the value of their NAME property, and return their CODE property in a list:"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-java"}),'joern> cpg.call.filter(node => node.name == "exit").code.l\nres0: List[String] = List("exit(0)", "exit(42)")\n')),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"filter")," steps can be chained together:"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-java"}),'joern> cpg.call.filter(node => node.name == "exit").filter(node => node.code.contains("42")).code.l \nres0: List[String] = List("exit(42)")\n')),Object(i.b)("p",null,"And their expression can contain any combination of boolean statements:"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-java"}),'joern> cpg.call.filter(node => node.name == "exit" && node.code.contains("42")).code.l \nres0: List[String] = List("exit(42)")\n\n// equivalent in logic to the query above\njoern> cpg.call.filter(node => true && 1 == 1 && node.name == "exit" && node.code.contains("42")).code.l \nres0: List[String] = List("exit(42)")\n')),Object(i.b)("p",null,"One helpful trick is to use the shorthand ",Object(i.b)("inlineCode",{parentName:"p"},"_")," operator in ",Object(i.b)("inlineCode",{parentName:"p"},"filter")," expressions, which points to the single argument that is passed into it, that is, the node."),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-java"}),'// long form\njoern> cpg.call.filter(node => node.name == "exit").code.l\nres0: List[String] = List("exit(0)", "exit(42)")\n\n// short form\njoern> cpg.call.filter(_.name == "exit").code.l\nres1: List[String] = List("exit(0)", "exit(42)")\n')),Object(i.b)("h3",{id:"where"},"where"),Object(i.b)("p",null,"Just like ",Object(i.b)("inlineCode",{parentName:"p"},"filter"),", the ",Object(i.b)("inlineCode",{parentName:"p"},"where")," ",Object(i.b)("em",{parentName:"p"},"Step")," is a ",Object(i.b)("em",{parentName:"p"},"Filter Step")," (",Object(i.b)("inlineCode",{parentName:"p"},"\u0ca0~\u0ca0"),") which continues a traversal for all nodes which pass its criterion. The expression representing the criterion takes in one argument, a variable that represents the traversal of the previous step, and returns another traversal. Say you'd like to query the Code Property Graph of the ",Object(i.b)("inlineCode",{parentName:"p"},"X42")," program again for all CALL nodes which have ",Object(i.b)("inlineCode",{parentName:"p"},"exit")," as the value of their NAME property, and return the value of their CODE property in a list:"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-java"}),'joern> cpg.call.where(node => node.name("exit")).code.l \nres0: List[String] = List("exit(0)", "exit(42)")\n\n// or using the `_` shorthand:\njoern> cpg.call.where(_.name("exit")).code.l \nres1: list[string] = list("exit(0)", "exit(42)")\n')),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"where"),"'s expression supports traversals of any length:"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-java"}),'joern> cpg.call.where(_.name("exit").argument.code("42")).code.l \nres0: List[String] = List("exit(42)")\n')),Object(i.b)("p",null,"And just like ",Object(i.b)("inlineCode",{parentName:"p"},"where"),", it supports chaining:"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-java"}),'// equivalent to the previous query\njoern> cpg.call.where(_.name("exit")).where(_.argument.code("42")).code.l \nres0: List[String] = List("exit(42)")\n')),Object(i.b)("h3",{id:"wherenot"},"whereNot"),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"whereNot")," is the inverse operation of the ",Object(i.b)("inlineCode",{parentName:"p"},"where")," ",Object(i.b)("em",{parentName:"p"},"Step"),"."),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-java"}),'joern> cpg.call.whereNot(_.name("exit")).code.l \nres0: List[String] = List(\n  "printf(\\"What is the meaning of life?\\\\n\\")",\n  "fprintf(stderr, \\"It depends!\\\\n\\")",\n  "argv[1]",\n  "strcmp(argv[1], \\"42\\")",\n  "strcmp(argv[1], \\"42\\") == 0",\n  "argc > 1",\n  "argc > 1 && strcmp(argv[1], \\"42\\") == 0"\n)\n')),Object(i.b)("p",null,"It supports chaining as well:"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-java"}),'joern> cpg.call.whereNot(_.name("exit")).whereNot(_.name("strcmp")).code.l \nres0: List[String] = List(\n  "printf(\\"What is the meaning of life?\\\\n\\")",\n  "fprintf(stderr, \\"It depends!\\\\n\\")",\n  "argv[1]",\n  "strcmp(argv[1], \\"42\\") == 0",\n  "argc > 1",\n  "argc > 1 && strcmp(argv[1], \\"42\\") == 0"\n)\n')),Object(i.b)("p",null,"And traversals of any length:"),Object(i.b)("pre",null,Object(i.b)("code",Object(r.a)({parentName:"pre"},{className:"language-java"}),'joern> cpg.call.whereNot(_.name("exit").argument.code("42")).whereNot(_.name("strcmp")).code.l \nres0: List[String] = List(\n  "exit(0)",\n  "printf(\\"What is the meaning of life?\\\\n\\")",\n  "fprintf(stderr, \\"It depends!\\\\n\\")",\n  "argv[1]",\n  "strcmp(argv[1], \\"42\\") == 0",\n  "argc > 1",\n  "argc > 1 && strcmp(argv[1], \\"42\\") == 0"\n)\n')))}s.isMDXComponent=!0}}]);
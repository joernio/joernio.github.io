(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{107:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return d})),n.d(t,"metadata",(function(){return u})),n.d(t,"toc",(function(){return h})),n.d(t,"default",(function(){return O}));var a=n(3),o=n(7),r=n(0),i=n.n(r),s=n(108),c=n(113),l=n(4),b=n(195),p=(n(96),function(e){function t(t){var n;return(n=e.call(this,t)||this).state={src:t.src,alt:t.alt,showAltTextInCaption:t.showAltTextInCaption,isOpen:!1},n}return Object(l.a)(t,e),t.prototype.render=function(){var e=this,t=this.state,n=(t.photoIndex,t.isOpen),a=t.src,o=t.alt;t.showAltTextInCaption;return i.a.createElement("div",{style:{marginBottom:"2rem"}},i.a.createElement("img",{style:{cursor:"pointer"},alt:o,src:a,onClick:function(){return e.setState({isOpen:!0})}}),i.a.createElement("div",null,i.a.createElement("span",{style:{textAlign:"center",width:"100%",display:"block",fontStyle:"italic"}},o)),n&&i.a.createElement(b.a,{mainSrc:a,imageCaption:o,onCloseRequest:function(){return e.setState({isOpen:!1})}}))},t}(r.Component)),d={id:"c-syntaxtree",title:"Syntax-Tree Queries",joern_shared:!0},u={unversionedId:"c-syntaxtree",id:"c-syntaxtree",isDocsHomePage:!1,title:"Syntax-Tree Queries",description:"In this article, we introduce readers to syntax-tree queries and show",source:"@site/docs/c-syntaxtree.mdx",slug:"/c-syntaxtree",permalink:"/c-syntaxtree",editUrl:"https://github.com/joernio/website/edit/master/docs.joern.io/docs/c-syntaxtree.mdx",version:"current",sidebar:"docs",previous:{title:"Traversal Basics",permalink:"/traversal-basics"},next:{title:"Developing Plugins",permalink:"/extensions"}},h=[{value:"What are Abstract Syntax Trees?",id:"what-are-abstract-syntax-trees",children:[]},{value:"Basic AST Traversals",id:"basic-ast-traversals",children:[]},{value:"Control Structures",id:"control-structures",children:[]},{value:"Nesting of control structures",id:"nesting-of-control-structures",children:[]}],m={toc:h};function O(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(s.b)("wrapper",Object(a.a)({},m,n,{components:t,mdxType:"MDXLayout"}),Object(s.b)("p",null,"In this article, we introduce readers to syntax-tree queries and show\nhow they can be used as a computationally cheap approach for\nidentifying code that handles attacker-controlled input or follows\nknown bad practices. On the one hand, this article provides a\npractical introduction to mining code for patterns in its abstract\nsyntax trees via a fluent query language. On the other hand, we\ndiscuss the limitations of syntax-tree queries at length."),Object(s.b)("div",{className:"admonition admonition-note alert alert--secondary"},Object(s.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-heading"}),Object(s.b)("h5",{parentName:"div"},Object(s.b)("span",Object(a.a)({parentName:"h5"},{className:"admonition-icon"}),Object(s.b)("svg",Object(a.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(s.b)("path",Object(a.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})))),"note")),Object(s.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-content"}),Object(s.b)("p",{parentName:"div"},"If you find that the terminology used in this article is foreign to\nyou, we hope that our ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"code-property-graph"}),"article on Code Property\nGraphs")," can help you out."))),Object(s.b)("h2",{id:"what-are-abstract-syntax-trees"},"What are Abstract Syntax Trees?"),Object(s.b)("p",null,"Throughout this article, we are using variations of the following\nsmall sample code snippet taken (taken from ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"https://fabs.codeminers.org/papers/2014-ieeesp.pdf"}),"this\npaper"),"):"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-bash"}),'val code = """\nvoid foo () {\n  int x = source();\n  if(x < MAX) {\n    int y = 2*x;\n    sink(y);\n  }\n}\n"""\n')),Object(s.b)("p",null,"The snippet consists of a single function named ",Object(s.b)("inlineCode",{parentName:"p"},"foo")," without a return\nvalue. It calls a function called ",Object(s.b)("inlineCode",{parentName:"p"},"source")," on line 2 and stores its\nresult in an integer called ",Object(s.b)("inlineCode",{parentName:"p"},"x"),". A subsequent check on line 3\ndetermines whether ",Object(s.b)("inlineCode",{parentName:"p"},"x")," is smaller than a constant ",Object(s.b)("inlineCode",{parentName:"p"},"MAX"),", and if so, the\nvalue of ",Object(s.b)("inlineCode",{parentName:"p"},"2*x")," is stored in y on line 4 and passed as an argument to the\nfunction ",Object(s.b)("inlineCode",{parentName:"p"},"sink")," on line 5."),Object(s.b)("p",null,"We can import this code snippet directly on the Joern shell."),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-bash"}),"importCode.c.fromString(code)\n")),Object(s.b)("p",null,"Once imported, we can plot the abstract syntax tree of ",Object(s.b)("inlineCode",{parentName:"p"},"foo")," to get a\nfirst idea of what an abstract syntax tree is."),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-bash"}),'cpg.method.name("foo").plotDotAst\n')),Object(s.b)(p,{alt:"Fig.1: Abstract Syntax Tree for function `foo`. (Click to zoom in)",src:Object(c.a)("img/tree.png"),showAltTextInCaption:"true",mdxType:"ImageWithDialog"}),Object(s.b)("p",null,"As shown in the sample plot in Figure 1, an abstract syntax tree is a\ntree-like structure that makes the decomposition of code into its\nlanguage constructs explicit. The tree consists of ",Object(s.b)("em",{parentName:"p"},"nodes")," and ",Object(s.b)("em",{parentName:"p"},"edges"),"\nvisualized in the plot as ellipses and arrows respectively."),Object(s.b)("p",null,"Nodes represent language constructs such as methods, variables, and\ncontrol structures, while edges indicate decomposition. For example,\nat the very top of the tree, we see a node representing the entire\nfunction ",Object(s.b)("inlineCode",{parentName:"p"},"foo"),", and directly beneath it, we see a node for the return\ntype ",Object(s.b)("inlineCode",{parentName:"p"},"void")," and one for the function body, denoted as a ",Object(s.b)("inlineCode",{parentName:"p"},"BLOCK"),". The\nedges between the function- and the two other nodes indicates that the\nfunction can be decomposed into a return type and a block of code, and\noutgoing edges from ",Object(s.b)("inlineCode",{parentName:"p"},"BLOCK")," show that this block of code can be\nfurther decomposed."),Object(s.b)("div",{className:"admonition admonition-note alert alert--secondary"},Object(s.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-heading"}),Object(s.b)("h5",{parentName:"div"},Object(s.b)("span",Object(a.a)({parentName:"h5"},{className:"admonition-icon"}),Object(s.b)("svg",Object(a.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(s.b)("path",Object(a.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})))),"note")),Object(s.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-content"}),Object(s.b)("p",{parentName:"div"},"In the plot, the pair ",Object(s.b)("inlineCode",{parentName:"p"},"(type,attribute)")," is displayed in each node,\nwhere ",Object(s.b)("inlineCode",{parentName:"p"},"type")," is the node type and attribute is one of the values\nthat is particularly indicative for the node, e.g., the method name\nfor method nodes. We make an exception for calls, where we display the\npair ",Object(s.b)("inlineCode",{parentName:"p"},"(name,attribute)"),"."))),Object(s.b)("h2",{id:"basic-ast-traversals"},"Basic AST Traversals"),Object(s.b)("p",null,"The most basic ",Object(s.b)("a",Object(a.a)({parentName:"p"},{href:"traversal-basics"}),"traversal")," that you can\nexecute on any AST node is ",Object(s.b)("inlineCode",{parentName:"p"},"ast"),", which traverses to all nodes of the\nAST rooted in the node. For example,"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-bash"}),'cpg.method("foo").ast.l\n')),Object(s.b)("p",null,"gives you all AST nodes of the AST for the method ",Object(s.b)("inlineCode",{parentName:"p"},"foo"),". As each AST\nnode is also the root of a subtree, you can also think of this\noperation as an enumeration of all subtrees. These can be filtered by\ntype. For example,"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{}),'cpg.method("foo").ast.isCall.code.l\n')),Object(s.b)("p",null,"gives you all outgoing calls from ",Object(s.b)("inlineCode",{parentName:"p"},"foo")," while"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{}),'cpg.method("foo").ast.isControlStructure.code.l\n')),Object(s.b)("p",null,"gives you all control structures. For method nodes, we also offer\nshorthands for the most common node types. Using these shorthands, the\ntwo queries can be written as"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{}),'cpg.method("foo").call.code.l\n')),Object(s.b)("p",null,"and"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{}),'cpg.method("foo).controlStructure.code.l\n')),Object(s.b)("p",null,"respectively."),Object(s.b)("p",null,"It is also possible to walk the tree upwards using ",Object(s.b)("inlineCode",{parentName:"p"},"inAst")," or\n",Object(s.b)("inlineCode",{parentName:"p"},"inAstMinusLeaf")," where the latter excludes the start node. In our\nrunning example, consider for example the situation where it is known\nthat calls to ",Object(s.b)("inlineCode",{parentName:"p"},"source")," return values that an attacker can\ninfluence."),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-bash"}),'cpg.call.name("source").inAstMinusLeaf.isCall.name(".*assignment.*").argument(1).l\n')),Object(s.b)("p",null,"The query begins by selecting all calls to ",Object(s.b)("inlineCode",{parentName:"p"},"source"),", encoded in the\ngraph as nodes of type ",Object(s.b)("inlineCode",{parentName:"p"},"CALL")," with a string property called ",Object(s.b)("inlineCode",{parentName:"p"},"name"),"\nthat is set to ",Object(s.b)("inlineCode",{parentName:"p"},'"source"'),". From there, we walk edges backwards\nuntil we reach the method node using ",Object(s.b)("inlineCode",{parentName:"p"},"inAstMinusLeaf"),". For the set of\nnodes thus collected, we determine only those which are calls\n(",Object(s.b)("inlineCode",{parentName:"p"},"isCall"),") to the assignment operator ",Object(s.b)("inlineCode",{parentName:"p"},'.name(".*assignment.*")'),". For\neach of these, we determine their first argument, the assignment\ntarget."),Object(s.b)("p",null,"As certain operators exist across programming languages and operating\non them via AST-queries is common, we have created a decorator\nlanguage to simplify these queries. In practice, we would write the\nfollowing query that is equivalent to the former query."),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-bash"}),'cpg.call("source").inAssignment.target.l\n')),Object(s.b)("h2",{id:"control-structures"},"Control Structures"),Object(s.b)("p",null,"Abstract syntax trees include control structures such as ",Object(s.b)("inlineCode",{parentName:"p"},"if"),"-,\n",Object(s.b)("inlineCode",{parentName:"p"},"while")," or ",Object(s.b)("inlineCode",{parentName:"p"},"for"),"-statements. Our example program contains only a\nsingle control structure, namely, the ",Object(s.b)("inlineCode",{parentName:"p"},"if"),"-statement on line 3."),Object(s.b)(p,{alt:"Fig.3: Control structure in the abstract syntax\ntree. The subtree on the left represents the condition, the subtree on\nthe right is the compound statement.",src:Object(c.a)("img/ast3.png"),showAltTextInCaption:"true",mdxType:"ImageWithDialog"}),Object(s.b)("p",null,"Figure 3 shows how ",Object(s.b)("inlineCode",{parentName:"p"},"if"),"-statements are represented in the syntax\ntree. The tree consists of two sub trees, one that holds the condition\n",Object(s.b)("inlineCode",{parentName:"p"},"x < MAX")," and another that holds the statements in the\n",Object(s.b)("inlineCode",{parentName:"p"},"if"),"-block. Conditions can be selected as follows:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-bash"}),'cpg.method("foo").controlStructure.condition.code.l\n=> List("x < MAX")\n')),Object(s.b)("p",null,"The body of the if-statement can be selected using ",Object(s.b)("inlineCode",{parentName:"p"},"whenTrue"),":"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-bash"}),'cpg.method("foo").controlStructure.whenTrue.l\nres16: List[AstNode] = List(\n  Block(\n    id -> 17L,\n    code -> "",\n    order -> 2,\n    argumentIndex -> 2,\n    typeFullName -> "void",\n    dynamicTypeHintFullName -> List(),\n    lineNumber -> Some(5),\n    columnNumber -> Some(4),\n    depthFirstOrder -> None,\n    internalFlags -> None\n  )\n)\n')),Object(s.b)("p",null,"For ",Object(s.b)("inlineCode",{parentName:"p"},"if-else")," constructs, ",Object(s.b)("inlineCode",{parentName:"p"},"whenFalse")," returns the else block, however,\nsince no ",Object(s.b)("inlineCode",{parentName:"p"},"else")," block exists in our example, an empty list is\nreturned:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{}),'cpg.method("foo").controlStructure.whenFalse.l\n=> List[AstNode] = List()\n')),Object(s.b)("p",null,"As each of the nodes returned by ",Object(s.b)("inlineCode",{parentName:"p"},".ast")," are also roots of syntax\ntrees, we can identify nested structures by chaining basic\noperations."),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{}),'cpg.method("foo").controlStructure.whenTrue.ast.isCall.code.l\n=> List[String] = List("y = 2*x", "sink(y)", "2*x")\n')),Object(s.b)("p",null,"yields all calls nested inside if blocks. You may ask yourself why\n",Object(s.b)("inlineCode",{parentName:"p"},"2*x")," is returned as a call. The reason is that we model all\ninvocations of built-in operators as calls to methods with the name\n",Object(s.b)("inlineCode",{parentName:"p"},"<operator>.$operatorName"),', where $operatorName may for example be\n"multiplication", or "assignment".'),Object(s.b)("p",null,"One example scenario where control structure access comes in handy is\nwhen you wish to determine all methods that call a specific function\nbut do not include a necessary check. Say, for example, that we want\nto identify functions that call ",Object(s.b)("inlineCode",{parentName:"p"},"source")," but they do not include a\ncheck against ",Object(s.b)("inlineCode",{parentName:"p"},"MAX"),". The following query achieves this:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-bash"}),'cpg.method.filterNot(_.controlStructure(".*MAX.*"))\n          .filter(_.callee.name(".*source.*")).l\n=> List()\n')),Object(s.b)("p",null,"Note, however, that the query does not specify the oder in which these\nstatements must occur, e.g., the check may happen too late. Control\nflow graphs and dominator trees are the right tools to reason about\nstatement order. These structures are available in the code property\ngraph as well, but we do not discuss them in this article."),Object(s.b)("h2",{id:"nesting-of-control-structures"},"Nesting of control structures"),Object(s.b)("p",null,"Let us modify our example code slightly as follows to obtain a deeper\nunderstanding of what one can and cannot do using the control\nstructures exposed by abstract syntax trees."),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-bash"}),'val code = """\nvoid foo () {\n  int x = source();\n\n  if (x > 10) {\n    goto end;\n  }\n\n  while(x++ < MAX) {\n    if(x != 0) {\n        int y = 2*x;\n        sink(y);\n    }\n  }\n\n  end:\n}\n"""\n')),Object(s.b)("p",null,"Importing and plotting yields the following:"),Object(s.b)(p,{alt:"Fig. 4: Abstract syntax tree containing\nstructured and unstructured control structures",src:Object(c.a)("img/ast4.png"),showAltTextInCaption:"true",mdxType:"ImageWithDialog"}),Object(s.b)("p",null,"As we can see in Figure 4, the language formulated so far can be used\neasily to describe nested constructs. For example, if we would like to\nidentify all calls to ",Object(s.b)("inlineCode",{parentName:"p"},"sink")," nested in an ",Object(s.b)("inlineCode",{parentName:"p"},"if"),"-block that is itself\nnested in a ",Object(s.b)("inlineCode",{parentName:"p"},"while")," block, we could use the following query:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-bash"}),'cpg.call("sink")\n    .inAst.filter(_.isControlStructure.code("if.*"))\n    .inAst.filter(_.isControlStructure.code("while.*")).l\n\n=> List[AstNode] = List(\n  ControlStructure(\n    id -> 19L,\n    code -> "while(x++ < MAX)",\n    columnNumber -> Some(2),\n    lineNumber -> Some(9),\n    order -> 3,\n    parserTypeName -> "WhileStatement",\n    argumentIndex -> 3,\n    depthFirstOrder -> None,\n    internalFlags -> None\n  )\n)\n')),Object(s.b)("p",null,"Alternatively, we can walk the tree from its top to achieve the same:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{}),' cpg.method\n    .controlStructure("while.*")\n    .ast.isControlStructure.code("if.*")\n    .ast.isCallTo("sink").l\n\n=> List[Call] = List(\n  Call(\n    id -> 36L,\n    code -> "sink(y)",\n    name -> "sink",\n    order -> 2,\n    methodInstFullName -> None,\n    methodFullName -> "sink",\n    argumentIndex -> 2,\n    dispatchType -> "STATIC_DISPATCH",\n    signature -> "TODO assignment signature",\n    typeFullName -> "ANY",\n    dynamicTypeHintFullName -> List(),\n    lineNumber -> Some(12),\n    columnNumber -> Some(0),\n    resolved -> None,\n    depthFirstOrder -> None,\n    internalFlags -> None\n  )\n)\n')),Object(s.b)("p",null,"While the syntax tree is not primarily concerned with exposing control\nflow, when a function only contains structured control structures such\nas ",Object(s.b)("inlineCode",{parentName:"p"},"if")," blocks or ",Object(s.b)("inlineCode",{parentName:"p"},"while")," loops, limited reasoning about control flow\nis possible. For example, since the call to ",Object(s.b)("inlineCode",{parentName:"p"},"sink")," is nested inside\nthe ",Object(s.b)("inlineCode",{parentName:"p"},"if")," block and ",Object(s.b)("inlineCode",{parentName:"p"},"while")," loop, we can be certain that the conditions\nintroduced by these two control structures are evaluated at least once\nbefore ",Object(s.b)("inlineCode",{parentName:"p"},"sink")," is called. We can also be certain that a sibling tree to\nthe left is executed before a tree itself."),Object(s.b)("p",null,"This, however, does not work in the face of unstructured control flow\nas introduced by ",Object(s.b)("inlineCode",{parentName:"p"},"goto"),". We make these statements as well as their\njump targets visible in the tree, however, allowing functions where\ncontrol flow must be analyzed with control flow graphs can be\ndetermined."))}O.isMDXComponent=!0}}]);
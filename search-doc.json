[{"title":"Code Property Graph","type":0,"sectionRef":"#","url":"code-property-graph","content":"","keywords":""},{"title":"Building Blocks of Code Property Graphs","type":1,"pageTitle":"Code Property Graph","url":"code-property-graph#building-blocks-of-code-property-graphs","content":"Code property graphs aregraphs, and more specifically property graphs. A property graph is composed of the following building blocks: Nodes and their types. Nodes represent program constructs. This includes low-level language constructs such as methods, variables, and control structures, but also higher level constructs such as HTTP endpoints or findings. Each node has a type. The type indicates the type of program construct represented by the node, e.g., a node with the type METHOD represents a method while a node with type LOCAL represents the declaration of a local variable. Labeled directed edges.Relations between program constructs are represented via edges between their corresponding nodes. For example, to express that a method contains a local variable, we can create an edge with the label CONTAINS from the method's node to the local's node. By using labeled edges, we can represent multiple types of relations in the same graph. Moreover, edges are directed to express, e.g., that the method contains the local but not the other way around. Multiple edges may exist between the same two nodes. Key-Value Pairs.Nodes carry key-value pairs (attributes), where the valid keys depend on the node type. For example, a method has at least a name and a signature while a local declaration has at least the name and the type of the declared variable. In summary, code property graphs are directed, edge-labeled, attributed multigraphs, and we insist that each node carries at least one attribute that indicates its type. "},{"title":"Node Types of the Base Specification","type":1,"pageTitle":"Code Property Graph","url":"code-property-graph#node-types-of-the-base-specification","content":"This section describes all node types of the base specification in detail. "},{"title":"MetaData","type":1,"pageTitle":"Code Property Graph","url":"code-property-graph#metadata","content":"Signature: MetaData(language : String, version: String, overlays: List[String], [hash : String]) Layer: Base Each CPG has exactly one MetaData node. The node holds the following information about the CPG generation: language: the CPG language frontend that generated this CPG.version: The version of the CPG specoverlays: The list of overlays that have been applied to create this graphhash: The artifact that this graph was generated from. The overlays field does not have to be set by the language frontend. Upon first loading the CPG, Joern/Ocular will add the semantic CPG layer, and hence, when the user first sees this field, it should start with the entrysemanticcpg. Note that the base layer is not considered an overlay and therefore it is not added to the overlays list. No incoming or outgoing edges are permitted for the meta data node. "},{"title":"AstNode","type":1,"pageTitle":"Code Property Graph","url":"code-property-graph#astnode","content":"Signature: AstNode(order : Int) AstNode is the base node type for all nodes that are part of syntax trees stored in the graph. In a syntax tree, sibling nodes (nodes who share a parent node) are ordered. As some graph databases do not guarantee the order in which siblings are returned to be stable, we make the ordering explicit by storing the position of each node relative to its siblings in the orderfield. In the left most sibling, order is set to 0, while in the right-most sibling, it is set to n-1 where n is the number of siblings. "},{"title":"File","type":1,"pageTitle":"Code Property Graph","url":"code-property-graph#file","content":"Signature: File(name: String, [hash: String]) is an AstNodeLayer: Semanticcpg Planned changes: File nodes shall no longer inherit from AstNode and shall only allow incoming SOURCE_FILE edges. Code property graphs are created from sets of files. Information about these files is stored in the graph to enable queries to map nodes of the graph back to the files that contain the code they represent. For each file, the graph must contain exactly one File node with the following fields: name: the absolute path of the file at CPG construction time in Unix style. No two file nodes of the CPG may have the same name field.hash (optional): A hash value calculated over the file contents. As file nodes are root nodes of abstract syntax tress, they are AstNodesand their order field is set to 0. Each code property graph must contain a special file node withname set to \"<unknown>\". This node is a placeholder used in cases where a file cannot be determined at compile time. As an example, consider the case where an external type is introduced only at link time. Conceptually file nodes serve as indices, e.g., they map all filenames to the list of methods they contain. File nodes MUST NOT be created by the language frontend. Instead, the language frontend is assumed to fill out the FILENAME field wherever possible, allowing File nodes to be created automatically when the semantic CPG layer is created. Associated Tests Related passes: FileCreationPass ... (More node types to follow) note A Look into the Rear-View Mirror The Code Property Graph was first introduced in the paper Modeling and Discovering Vulnerabilities with Code Property Graphs in the context of vulnerability discovery for C system code and the Linux kernel in particular. The core ideas outlined in this early work are the following: Different classic program representations are merged into a property graph into a single data structure that holds information about the program’s syntax, control- and intra-procedural data-flow. The property graph is stored in a graph database and made accessible via a domain specific language (DSL) for the identification of programming patterns - based on a DSL for graph traversals. The query language allows to seamlessly transition between the original code representations, making it possible to combine aspects of the code from different views these representations offer in a single query. From 2014-2016, research followed on (a) extending the concept for interprocedural analysis, (b) using the graph as a basis for learning typical data-flow patterns in a program, (c) the effects of introducing further classic program representations such as dominator trees, (d) and the applicability of the approach for dynamically-typed languages such as PHP. From 2017 onwards, the code property graph served as the technological foundation for the static analysis solutions developed at ShiftLeft Inc. The representation has since undergone heavy extensions and transformations. At the statement and expression level, it has matured into a generic container format which allows for hosting of graphs generated by 8 different language frontends, to enable querying with the same query language across programming languages. Moreover, the concept of overlays was introduced to allow representing code on different levels of abstraction, enabling transitioning between these layers of abstraction using the query language in the same way as for the original three low-level code representations. Finally, programming models and APIs are now available for parallel graph processing at low memory footprint - a core ingredient for scaling the approach. "},{"title":"Syntax-Tree Queries","type":0,"sectionRef":"#","url":"c-syntaxtree","content":"","keywords":""},{"title":"What are Abstract Syntax Trees?","type":1,"pageTitle":"Syntax-Tree Queries","url":"c-syntaxtree#what-are-abstract-syntax-trees","content":"Throughout this article, we are using variations of the following small sample code snippet taken (taken from this paper): val code = \"\"\" void foo () { int x = source(); if(x < MAX) { int y = 2*x; sink(y); } } \"\"\" Copy The snippet consists of a single function named foo without a return value. It calls a function called source on line 2 and stores its result in an integer called x. A subsequent check on line 3 determines whether x is smaller than a constant MAX, and if so, the value of 2*x is stored in y on line 4 and passed as an argument to the function sink on line 5. We can import this code snippet directly on the Joern shell. importCode.c.fromString(code) Copy Once imported, we can plot the abstract syntax tree of foo to get a first idea of what an abstract syntax tree is. cpg.method.name(\"foo\").plotDotAst Copy Fig.1: Abstract Syntax Tree for function `foo`. (Click to zoom in) As shown in the sample plot in Figure 1, an abstract syntax tree is a tree-like structure that makes the decomposition of code into its language constructs explicit. The tree consists of nodes and edgesvisualized in the plot as ellipses and arrows respectively. Nodes represent language constructs such as methods, variables, and control structures, while edges indicate decomposition. For example, at the very top of the tree, we see a node representing the entire function foo, and directly beneath it, we see a node for the return type void and one for the function body, denoted as a BLOCK. The edges between the function- and the two other nodes indicates that the function can be decomposed into a return type and a block of code, and outgoing edges from BLOCK show that this block of code can be further decomposed. note In the plot, the pair (type,attribute) is displayed in each node, where type is the node type and attribute is one of the values that is particularly indicative for the node, e.g., the method name for method nodes. We make an exception for calls, where we display the pair (name,attribute). "},{"title":"Basic AST Traversals","type":1,"pageTitle":"Syntax-Tree Queries","url":"c-syntaxtree#basic-ast-traversals","content":"The most basic traversal that you can execute on any AST node is ast, which traverses to all nodes of the AST rooted in the node. For example, cpg.method(\"foo\").ast.l Copy gives you all AST nodes of the AST for the method foo. As each AST node is also the root of a subtree, you can also think of this operation as an enumeration of all subtrees. These can be filtered by type. For example, cpg.method(\"foo\").ast.isCall.code.l Copy gives you all outgoing calls from foo while cpg.method(\"foo\").ast.isControlStructure.code.l Copy gives you all control structures. For method nodes, we also offer shorthands for the most common node types. Using these shorthands, the two queries can be written as cpg.method(\"foo\").call.code.l Copy and cpg.method(\"foo).controlStructure.code.l Copy respectively. It is also possible to walk the tree upwards using inAst orinAstMinusLeaf where the latter excludes the start node. In our running example, consider for example the situation where it is known that calls to source return values that an attacker can influence. cpg.call.name(\"source\").inAstMinusLeaf.isCall.name(\".*assignment.*\").argument(1).l Copy The query begins by selecting all calls to source, encoded in the graph as nodes of type CALL with a string property called namethat is set to \"source\". From there, we walk edges backwards until we reach the method node using inAstMinusLeaf. For the set of nodes thus collected, we determine only those which are calls (isCall) to the assignment operator .name(\".*assignment.*\"). For each of these, we determine their first argument, the assignment target. As certain operators exist across programming languages and operating on them via AST-queries is common, we have created a decorator language to simplify these queries. In practice, we would write the following query that is equivalent to the former query. cpg.call(\"source\").inAssignment.target.l Copy "},{"title":"Control Structures","type":1,"pageTitle":"Syntax-Tree Queries","url":"c-syntaxtree#control-structures","content":"Abstract syntax trees include control structures such as if-,while or for-statements. Our example program contains only a single control structure, namely, the if-statement on line 3. Fig.3: Control structure in the abstract syntax tree. The subtree on the left represents the condition, the subtree on the right is the compound statement. Figure 3 shows how if-statements are represented in the syntax tree. The tree consists of two sub trees, one that holds the conditionx < MAX and another that holds the statements in theif-block. Conditions can be selected as follows: cpg.method(\"foo\").controlStructure.condition.code.l => List(\"x < MAX\") Copy The body of the if-statement can be selected using whenTrue: cpg.method(\"foo\").controlStructure.whenTrue.l res16: List[AstNode] = List( Block( id -> 17L, code -> \"\", order -> 2, argumentIndex -> 2, typeFullName -> \"void\", dynamicTypeHintFullName -> List(), lineNumber -> Some(5), columnNumber -> Some(4), depthFirstOrder -> None, internalFlags -> None ) ) Copy For if-else constructs, whenFalse returns the else block, however, since no else block exists in our example, an empty list is returned: cpg.method(\"foo\").controlStructure.whenFalse.l => List[AstNode] = List() Copy As each of the nodes returned by .ast are also roots of syntax trees, we can identify nested structures by chaining basic operations. cpg.method(\"foo\").controlStructure.whenTrue.ast.isCall.code.l => List[String] = List(\"y = 2*x\", \"sink(y)\", \"2*x\") Copy yields all calls nested inside if blocks. You may ask yourself why2*x is returned as a call. The reason is that we model all invocations of built-in operators as calls to methods with the name<operator>.$operatorName, where $operatorName may for example be \"multiplication\", or \"assignment\". One example scenario where control structure access comes in handy is when you wish to determine all methods that call a specific function but do not include a necessary check. Say, for example, that we want to identify functions that call source but they do not include a check against MAX. The following query achieves this: cpg.method.filterNot(_.controlStructure(\".*MAX.*\")) .filter(_.callee.name(\".*source.*\")).l => List() Copy Note, however, that the query does not specify the oder in which these statements must occur, e.g., the check may happen too late. Control flow graphs and dominator trees are the right tools to reason about statement order. These structures are available in the code property graph as well, but we do not discuss them in this article. "},{"title":"Nesting of control structures","type":1,"pageTitle":"Syntax-Tree Queries","url":"c-syntaxtree#nesting-of-control-structures","content":"Let us modify our example code slightly as follows to obtain a deeper understanding of what one can and cannot do using the control structures exposed by abstract syntax trees. val code = \"\"\" void foo () { int x = source(); if (x > 10) { goto end; } while(x++ < MAX) { if(x != 0) { int y = 2*x; sink(y); } } end: } \"\"\" Copy Importing and plotting yields the following: Fig. 4: Abstract syntax tree containing structured and unstructured control structures As we can see in Figure 4, the language formulated so far can be used easily to describe nested constructs. For example, if we would like to identify all calls to sink nested in an if-block that is itself nested in a while block, we could use the following query: cpg.call(\"sink\") .inAst.filter(_.isControlStructure.code(\"if.*\")) .inAst.filter(_.isControlStructure.code(\"while.*\")).l => List[AstNode] = List( ControlStructure( id -> 19L, code -> \"while(x++ < MAX)\", columnNumber -> Some(2), lineNumber -> Some(9), order -> 3, parserTypeName -> \"WhileStatement\", argumentIndex -> 3, depthFirstOrder -> None, internalFlags -> None ) ) Copy Alternatively, we can walk the tree from its top to achieve the same:  cpg.method .controlStructure(\"while.*\") .ast.isControlStructure.code(\"if.*\") .ast.isCallTo(\"sink\").l => List[Call] = List( Call( id -> 36L, code -> \"sink(y)\", name -> \"sink\", order -> 2, methodInstFullName -> None, methodFullName -> \"sink\", argumentIndex -> 2, dispatchType -> \"STATIC_DISPATCH\", signature -> \"TODO assignment signature\", typeFullName -> \"ANY\", dynamicTypeHintFullName -> List(), lineNumber -> Some(12), columnNumber -> Some(0), resolved -> None, depthFirstOrder -> None, internalFlags -> None ) ) Copy While the syntax tree is not primarily concerned with exposing control flow, when a function only contains structured control structures such as if blocks or while loops, limited reasoning about control flow is possible. For example, since the call to sink is nested inside the if block and while loop, we can be certain that the conditions introduced by these two control structures are evaluated at least once before sink is called. We can also be certain that a sibling tree to the left is executed before a tree itself. This, however, does not work in the face of unstructured control flow as introduced by goto. We make these statements as well as their jump targets visible in the tree, however, allowing functions where control flow must be analyzed with control flow graphs can be determined. "},{"title":"Calls","type":0,"sectionRef":"#","url":"cpgql/calls","content":"","keywords":""},{"title":"Traversal Steps","type":1,"pageTitle":"Calls","url":"cpgql/calls#traversal-steps","content":"Traversals\tDescription\tExample.call\tAll call-sites in the code\tcpg.call.name.l .callOut\tReturn the outgoing call-sites for a given method\tcpg.method.name(\"main\").callOut.name.l .callIn\tReturn the call-sites of a given method\tcpg.method.name(\"exit\").callIn.code.l "},{"title":"Common Usage Patterns","type":1,"pageTitle":"Calls","url":"cpgql/calls#common-usage-patterns","content":"note Use cpg.call.<TAB> to explore more available options Name\tUsageCode string\tcpg.call.code.l Call name\tcpg.call.name.l Location\tcpg.call.name(\"foo\").location.l Calling method\tcpg.call.name(\"foo\").method.l Argument\tcpg.call.name(\"foo\").argument.code.l Filter\tcpg.call.filter(_.argument.code(\"42\")).name.l "},{"title":"Sample Queries","type":1,"pageTitle":"Calls","url":"cpgql/calls#sample-queries","content":"List exact code strings of all the call-sites in the graph: joern> cpg.call.code.l res45: List[String] = List( \"exit(0)\", \"printf(\\\"What is the meaning of life?\\\\n\\\")\", \"exit(42)\", \"fprintf(stderr, \\\"It depends!\\\\n\\\")\", ... ) Copy Identify if an exit() call-site is called from within a conditional block (if { }) with a given condition. This can be done via first identifying a call named exit and then traversing the AST upwards (via astParent) until a if control structure is encountered. This only yields the specific exit which is withing the if block : joern> cpg.call.name(\"exit\").where(_.repeat(_.astParent)(_.until(_.isControlStructure.parserTypeName(\"If.*\")))).code.l res69: List[String] = List(\"exit(42)\") Copy Identify all the call-sites of exit() function in code, along with line-number and filename: joern> cpg.call.name(\"exit\").map( c=> (c.name, c.location.lineNumber.get, c.location.filename)).l res56: List[(String, Integer, String)] = List( (\"exit\", 11, \"/tmp/x42/c/X42.c\"), (\"exit\", 8, \"/tmp/x42/c/X42.c\") ) Copy List the arguments of all the exit() functions called in the code: joern> cpg.call.name(\"exit\").map( c=> (c.name, c.start.argument.code.l, c.location.lineNumber.get)).l res59: List[(String, List[String], Integer)] = List( (\"exit\", List(\"0\"), 11), (\"exit\", List(\"42\"), 8) ) Copy "},{"title":"Augmentation Directives","type":0,"sectionRef":"#","url":"cpgql/augmentation-directives","content":"","keywords":""},{"title":"newTagNode","type":1,"pageTitle":"Augmentation Directives","url":"cpgql/augmentation-directives#newtagnode","content":"newTagNode is an Augmentation Directive that adds tags with user-defined keys to the nodes that are part of the traversal they're suffixing. It works together with the store CPGQL Component which creates the actual nodes representing the tags, and the run.commit which merges those nodes in the active Code Property Graph. Say for example that you'd like to add tags to all the nodes of X42's Code Property Graph that represent calls to exit. That is, these two: // list all CALL nodes in the X42 program with the string \"exit\" in their CALL property joern> cpg.call.name(\"exit\").code.l res0: List[String] = List(\"exit(0)\", \"exit(42)\") Copy And say that you'd like to use the key MY_KIND_OF_EXIT for the tags you want to create: // create tags with the key MY_KIND_OF_EXIT for all CALL nodes which have the string \"exit\" in the value of their NAME property joern> cpg.call.name(\"exit\").newTagNode(\"MY_KIND_OF_EXIT\").store // apply the diffgraph to the currently active Code Property Graph joern> run.commit 2020-07-02 14:07:02.041 [main] INFO Enhancement io.shiftleft.console.Commit$$anon$1 completed in 0 milliseconds The graph has been modified. You may want to use the `save` command to persist changes to disk. All changes will also be saved collectively on exit res1: Cpg = io.shiftleft.codepropertygraph.Cpg@97c920b // list the newly created tags joern> cpg.tag.name(\"MY_KIND_OF_EXIT\").l res2: List[nodes.Tag] = List( Tag(id -> 42L, name -> \"MY_KIND_OF_EXIT\", value -> \"\"), Tag(id -> 41L, name -> \"MY_KIND_OF_EXIT\", value -> \"\") ) // list the CODE property of all CALL nodes attached to the newly created tags joern> cpg.tag.name(\"MY_KIND_OF_EXIT\").call.code.l res3: List[String] = List(\"exit(42)\", \"exit(0)\") Copy "},{"title":"newTagNodePair","type":1,"pageTitle":"Augmentation Directives","url":"cpgql/augmentation-directives#newtagnodepair","content":"newTagNodePair is very similar to newTagNode: it is an Augmentation Directive that adds tags with user-defined keys and user-defined values to the nodes that are part of the traversal they're suffixing. It also works together with store and run.commit, but you can specify both a key and a value for the nodes created: joern> cpg.call.name(\"exit\").newTagNodePai(\"MY_OTHER_KIND_OF_EXIT\", \"MY_VALUE\").store joern> run.commit 2020-07-02 14:07:02.041 [main] INFO Enhancement io.shiftleft.console.Commit$$anon$1 completed in 0 milliseconds The graph has been modified. You may want to use the `save` command to persist changes to disk. All changes will also be saved collectively on exit res1: Cpg = io.shiftleft.codepropertygraph.Cpg@97c920b joern> cpg.tag.name(\"MY_OTHER_KIND_OF_EXIT\").l res2: List[nodes.Tag] = List( Tag(id -> 44L, name -> \"MY_OTHER_KIND_OF_EXIT\", value -> \"MY_VALUE\"), Tag(id -> 43L, name -> \"MY_OTHER_KIND_OF_EXIT\", value -> \"MY_VALUE\") ) joern> cpg.tag.value(\"MY_VALUE\").call.code.l res3: List[String] = List(\"exit(42)\", \"exit(0)\") Copy "},{"title":"Complex Steps","type":0,"sectionRef":"#","url":"cpgql/complex-steps","content":"","keywords":""},{"title":"Generic Complex Steps","type":1,"pageTitle":"Complex Steps","url":"cpgql/complex-steps#generic-complex-steps","content":""},{"title":"dump","type":1,"pageTitle":"Complex Steps","url":"cpgql/complex-steps#dump","content":"dump is a Complex Step which executes the traversal and returns the value of the CODE property of the nodes it suffixes with syntax-highlighting. joern> cpg.method.name(\"main\").dump res0: List[String] = List( \"\"\"int main(int argc, char *argv[]) { /* <=== */ if (argc > 1 && strcmp(argv[1], \"42\") == 0) { fprintf(stderr, \"It depends!\\n\"); exit(42); } printf(\"What is the meaning of life?\\n\"); exit(0); }\"\"\" ) Copy "},{"title":"dumpRaw","type":1,"pageTitle":"Complex Steps","url":"cpgql/complex-steps#dumpraw","content":"dumpRaw is a Complex Step which executes the traversal and returns the value of the CODE property of the nodes it suffixes. joern> cpg.method.name(\"main\").dumpRaw res0: List[String] = List( \"\"\"int main(int argc, char *argv[]) { /* <=== */ if (argc > 1 && strcmp(argv[1], \"42\") == 0) { fprintf(stderr, \"It depends!\\n\"); exit(42); } printf(\"What is the meaning of life?\\n\"); exit(0); }\"\"\" ) Copy "},{"title":"tagList","type":1,"pageTitle":"Complex Steps","url":"cpgql/complex-steps#taglist","content":"tagList is a Complex Step which executes the traversal and returns the list of all TAG nodes found at each node visited by the traversal it suffixes. joern> cpg.method.tagList res0: List[List[TagBase]] = List(List(NewTag(\"MY_TAG\", \"\"))) Copy "},{"title":"Call Graph Steps","type":1,"pageTitle":"Complex Steps","url":"cpgql/complex-steps#call-graph-steps","content":"Call Graph Steps are Complex Steps which traverse the nodes of a Code Property Graph which represent a program's Call Graph. The following examples are run on the simple program named X42: public class X42 { public static void main(String[] args) { if (args.length > 0 && args[0].equals(\"42\")) { System.err.println(\"It depends!\"); System.exit(42); } System.out.println(\"What is the meaning of life?\"); System.exit(0); } } Copy "},{"title":"callee","type":1,"pageTitle":"Complex Steps","url":"cpgql/complex-steps#callee","content":"callee is a Call Graph Step which lists all nodes representing Call Graph callees of the traversed nodes. joern> cpg.method.name(\"main\").callee.name.l res0: List[String] = List( \"printf\", \"exit\", \"exit\", \"<operator>.logicalAnd\", \"<operator>.greaterThan\", \"<operator>.equals\", \"fprintf\", \"strcmp\", \"<operator>.indirectIndexAccess\" ) Copy "},{"title":"caller","type":1,"pageTitle":"Complex Steps","url":"cpgql/complex-steps#caller","content":"caller is a Call Graph Step which lists all nodes representing Call Graph callers of the traversed nodes. joern> cpg.method.name(\"exit\").caller.code.l res0: List[String] = List(\"main (int argc,char *argv[])\", \"main (int argc,char *argv[])\") Copy "},{"title":"callIn","type":1,"pageTitle":"Complex Steps","url":"cpgql/complex-steps#callin","content":"callIn is a Call Graph Step which lists all nodes representing Call Graph parent call-sites of the traversed nodes. joern> cpg.method.name(\"exit\").callIn.code.l res0: List[String] = List(\"exit(0)\", \"exit(42)\") Copy "},{"title":"inCall","type":1,"pageTitle":"Complex Steps","url":"cpgql/complex-steps#incall","content":"inCall is a Call Graph Step which lists all nodes representing surrounding Call Graph call-sites of the traversed nodes. joern> cpg.call.name(\"<operator>.indirectIndexAccess\").inCall.code.l res0: List[String] = List(\"strcmp(argv[1], \\\"42\\\")\") Copy "},{"title":"Dataflow Steps","type":1,"pageTitle":"Complex Steps","url":"cpgql/complex-steps#dataflow-steps","content":"Dataflow Steps are Complex Steps which traverse the nodes of a Code Property Graph which represent a program's data-flow. controlledBy, flows,passes, passesNot, source, sink, reachableBy are all CPGQL Components that are combined to construct Dataflow Steps. "},{"title":"Core Steps","type":0,"sectionRef":"#","url":"cpgql/core-steps","content":"","keywords":""},{"title":"map","type":1,"pageTitle":"Core Steps","url":"cpgql/core-steps#map","content":"The map Core Step is a Step which transforms objects in a traversal with an expression. Its expression takes one argument, a variable representing the item the map Core Step is suffixing, and can return any other type. For example, say that you'd like to return the value of the CODE property, together with the value of the TYPE_FULL_NAME property of all LITERAL nodes in X42's Code Property Graph: joern> cpg.literal.map(node => List(node.typeFullName, node.code)).toList res223: List[List[String]] = List( List(\"char *\", \"\\\"What is the meaning of life?\\\\n\\\"\"), List(\"int\", \"42\"), List(\"int\", \"0\"), List(\"char *\", \"\\\"It depends!\\\\n\\\"\"), List(\"int\", \"0\"), List(\"char *\", \"\\\"42\\\"\"), List(\"int\", \"1\"), List(\"int\", \"1\") ) Copy "},{"title":"sideEffect","type":1,"pageTitle":"Core Steps","url":"cpgql/core-steps#sideeffect","content":"sideEffect is a step that executes a function on each node of the traversal it suffixes. joern> cpg.literal.sideEffect(node => println(\"Called once for ID \" + node.id.toString())).code.l Called once for ID 32 Called once for ID 30 Called once for ID 34 Called once for ID 28 Called once for ID 24 Called once for ID 23 Called once for ID 22 Called once for ID 17 res0: List[String] = List( \"\\\"What is the meaning of life?\\\\n\\\"\", \"42\", \"0\", \"\\\"It depends!\\\\n\\\"\", \"0\", \"\\\"42\\\"\", \"1\", \"1\" ) Copy "},{"title":"dedup","type":1,"pageTitle":"Core Steps","url":"cpgql/core-steps#dedup","content":"dedup is a step that removes duplicates from the traversal it suffixes. For example, say you'd like to query X42's Code Property Graph for the AST parent nodes of all CALL nodes, and print out their CODE property: joern> cpg.call.astParent.isCall.code.l res0: List[String] = List( \"strcmp(argv[1], \\\"42\\\")\", \"strcmp(argv[1], \\\"42\\\") == 0\", \"argc > 1 && strcmp(argv[1], \\\"42\\\") == 0\", \"argc > 1 && strcmp(argv[1], \\\"42\\\") == 0\" ) Copy Because of the structure of the resulting AST, the query returns a duplicate result. To remove it, add dedup to the query: joern> cpg.call.astParent.isCall.dedup.code.l res0: List[String] = List( \"strcmp(argv[1], \\\"42\\\")\", \"strcmp(argv[1], \\\"42\\\") == 0\", \"argc > 1 && strcmp(argv[1], \\\"42\\\") == 0\" ) Copy "},{"title":"Execution Directives","type":0,"sectionRef":"#","url":"cpgql/execution-directives","content":"","keywords":""},{"title":"toList","type":1,"pageTitle":"Execution Directives","url":"cpgql/execution-directives#tolist","content":"joern> cpg.call.name.toList res0: List[String] = List( \"exit\", \"printf\", \"exit\", \"fprintf\", \"<operator>.indirectIndexAccess\", \"strcmp\", \"<operator>.equals\", \"<operator>.greaterThan\", \"<operator>.logicalAnd\" ) Copy "},{"title":"l","type":1,"pageTitle":"Execution Directives","url":"cpgql/execution-directives#l","content":"toList has a shorthand named l: joern> cpg.call.name.l res0: List[String] = List( \"exit\", \"printf\", \"exit\", \"fprintf\", \"<operator>.indirectIndexAccess\", \"strcmp\", \"<operator>.equals\", \"<operator>.greaterThan\", \"<operator>.logicalAnd\" ) Copy "},{"title":"head","type":1,"pageTitle":"Execution Directives","url":"cpgql/execution-directives#head","content":"Executes the traversal and returns the first result joern> cpg.call.name.head res0: List[String] = List( \"exit\", ) Copy "},{"title":"size","type":1,"pageTitle":"Execution Directives","url":"cpgql/execution-directives#size","content":"size executes the traversal and returns the size of the result set joern> cpg.call.size res0: Int = 9 Copy "},{"title":"Execution Directives and the Joern Interpreter","type":1,"pageTitle":"Execution Directives","url":"cpgql/execution-directives#execution-directives-and-the-joern-interpreter","content":"Execution Directives sit at the border between CPQGL Queries and the Joern Interpreter, that is at the border between querying Code Property Graphs, and using the results of those queries for further processing using the Scala programming language. For example, say you'd like to take the results of a query execution and write them to a text file: // first import the namespace for Java I/O joern> import java.io._ import java.io._ // afterwards open a file stream to a new file named `my-query-result.txt` joern> val pw = new PrintWriter(new File(\"./my-query-result.txt\" )) pw: PrintWriter = java.io.PrintWriter@fe4c8fc // execute your query and store the results in a constant joern> val myQueryResult = cpg.call.size myQueryResult: Int = 9 // cast myQueryResult to a string, and write it to the file stream joern> pw.write(myQueryResult.toString()) // close the file streasm joern> pw.close() Copy You'll see your results written to a file, ready for post-analysis: $ cat my-query-result.txt 9 Copy Writing the results of a query to a file can also be done in a more concise way using the |> operator provided by the Joern Interpreter: joern> cpg.call.size.toString() |> \"my-query-result.txt\" Copy "},{"title":"p","type":1,"pageTitle":"Execution Directives","url":"cpgql/execution-directives#p","content":"p executes the traversal and pretty-prints the results: joern> cpg.call.p res26: List[String] = List( \"(CALL,31): ARGUMENT_INDEX: 3, CODE: exit(0), COLUMN_NUMBER: 2, DISPATCH_TYPE: STATIC_DISPATCH, LINE_NUMBER: 11, METHOD_FULL_NAME: exit, NAME: exit, ORDER: 3, SIGNATURE: TODO assignment signature, TYPE_FULL_NAME: ANY\", \"(CALL,29): ARGUMENT_INDEX: 2, CODE: printf(\\\"What is the meaning of life?\\\\n\\\"), COLUMN_NUMBER: 2, DISPATCH_TYPE: STATIC_DISPATCH, LINE_NUMBER: 10, METHOD_FULL_NAME: printf, NAME: printf, ORDER: 2, SIGNATURE: TODO assignment signature, TYPE_FULL_NAME: ANY\", \"(CALL,27): ARGUMENT_INDEX: 2, CODE: exit(42), COLUMN_NUMBER: 4, DISPATCH_TYPE: STATIC_DISPATCH, LINE_NUMBER: 8, METHOD_FULL_NAME: exit, NAME: exit, ORDER: 2, SIGNATURE: TODO assignment signature, TYPE_FULL_NAME: ANY\", \"(CALL,24): ARGUMENT_INDEX: 1, CODE: fprintf(stderr, \\\"It depends!\\\\n\\\"), COLUMN_NUMBER: 4, DISPATCH_TYPE: STATIC_DISPATCH, LINE_NUMBER: 7, METHOD_FULL_NAME: fprintf, NAME: fprintf, ORDER: 1, SIGNATURE: TODO assignment signature, TYPE_FULL_NAME: ANY\", \"(CALL,18): ARGUMENT_INDEX: 1, CODE: argv[1], COLUMN_NUMBER: 25, DISPATCH_TYPE: STATIC_DISPATCH, LINE_NUMBER: 6, METHOD_FULL_NAME: <operator>.indirectIndexAccess, NAME: <operator>.indirectIndexAccess, ORDER: 1, SIGNATURE: TODO assignment signature, TYPE_FULL_NAME: ANY\", \"(CALL,17): ARGUMENT_INDEX: 1, CODE: strcmp(argv[1], \\\"42\\\"), COLUMN_NUMBER: 18, DISPATCH_TYPE: STATIC_DISPATCH, LINE_NUMBER: 6, METHOD_FULL_NAME: strcmp, NAME: strcmp, ORDER: 1, SIGNATURE: TODO assignment signature, TYPE_FULL_NAME: ANY\", \"(CALL,16): ARGUMENT_INDEX: 2, CODE: strcmp(argv[1], \\\"42\\\") == 0, COLUMN_NUMBER: 18, DISPATCH_TYPE: STATIC_DISPATCH, LINE_NUMBER: 6, METHOD_FULL_NAME: <operator>.equals, NAME: <operator>.equals, ORDER: 2, SIGNATURE: TODO assignment signature, TYPE_FULL_NAME: ANY\", \"(CALL,13): ARGUMENT_INDEX: 1, CODE: argc > 1, COLUMN_NUMBER: 6, DISPATCH_TYPE: STATIC_DISPATCH, LINE_NUMBER: 6, METHOD_FULL_NAME: <operator>.greaterThan, NAME: <operator>.greaterThan, ORDER: 1, SIGNATURE: TODO assignment signature, TYPE_FULL_NAME: ANY\", \"(CALL,12): ARGUMENT_INDEX: 1, CODE: argc > 1 && strcmp(argv[1], \\\"42\\\") == 0, COLUMN_NUMBER: 6, DISPATCH_TYPE: STATIC_DISPATCH, LINE_NUMBER: 6, METHOD_FULL_NAME: <operator>.logicalAnd, NAME: <operator>.logicalAnd, ORDER: 1, SIGNATURE: TODO assignment signature, TYPE_FULL_NAME: ANY\" ) Copy "},{"title":"toJson","type":1,"pageTitle":"Execution Directives","url":"cpgql/execution-directives#tojson","content":"toJson executes the traversal and returns the results in a JSON string: joern> cpg.call.name.toJson res28: String = \"[\\\"exit\\\",\\\"printf\\\",\\\"exit\\\",\\\"fprintf\\\",\\\"<operator>.indirectIndexAccess\\\",\\\"strcmp\\\",\\\"<operator>.equals\\\",\\\"<operator>.greaterThan\\\",\\\"<operator>.logicalAnd\\\"]\" Copy "},{"title":"toJsonPretty","type":1,"pageTitle":"Execution Directives","url":"cpgql/execution-directives#tojsonpretty","content":"toJsonPretty executes the traversal and returns the results in a pretty-printed JSON string: joern> cpg.call.name.toJsonPretty res29: String = \"\"\"[ \"exit\", \"printf\", \"exit\", \"fprintf\", \"<operator>.indirectIndexAccess\", \"strcmp\", \"<operator>.equals\", \"<operator>.greaterThan\", \"<operator>.logicalAnd\" ]\"\"\" Copy "},{"title":"size","type":1,"pageTitle":"Execution Directives","url":"cpgql/execution-directives#size-1","content":"size executes the traversal and returns the number of results: joern> cpg.call.size res0: Int = 9 Copy "},{"title":"Filter Steps","type":0,"sectionRef":"#","url":"cpgql/filter-steps","content":"","keywords":""},{"title":"Property Filter Steps","type":1,"pageTitle":"Filter Steps","url":"cpgql/filter-steps#property-filter-steps","content":"Property Filter Steps are Filter Steps which continue a traversal if the properties of the nodes they point to pass a certain criterion. For example, to query the Code Property Graph for all CALL nodes which have the string exit as the value for their CODE property: joern> cpg.call.name(\"exit\").code.l res0: List[String] = List(\"exit(0)\", \"exit(42)\") Copy The criterion is unique to every Property Filter Step. In the case of the name Property Filter Step of the call Node-Type Step, its criterion is a string that represents a regular expression; that is, all following queries will deliver the same result for the X42 program: joern> cpg.call.name(\"exit\").code.l res0: List[String] = List(\"exit(0)\", \"exit(42)\") joern> cpg.call.name(\"[eE]xit\").code.l res1: List[String] = List(\"exit(0)\", \"exit(42)\") joern> cpg.call.name(\"ex.*\").code.l res2: List[String] = List(\"exit(0)\", \"exit(42)\") Copy Just like all other Filter Steps, Property Filter Steps can be chained together: joern> cpg.call.name(\"exit\").code(\".*0.*\").code.l res0: List[String] = List(\"exit(0)\") Copy Unlike Property Directives, Property Filter Steps are usually greater in number than the properties defined on a node type. Most Property Filter Steps have their negated version available: joern> cpg.call.name(\"exit\").codeNot(\".*0.*\").code.l res0: List[String] = List(\"exit(42)\") Copy "},{"title":"filter","type":1,"pageTitle":"Filter Steps","url":"cpgql/filter-steps#filter","content":"The filter Step is a Filter Step which continues a traversal for all nodes which pass its criterion. The criterion of the filter step is represented by an expression which has one argument, a variable that points to the node matched in the previous step, and which returns a boolean. For example, suppose you'd like to query the Code Property Graph of the X42 program for all CALL nodes which have exit as the value of their NAME property, and return their CODE property in a list: joern> cpg.call.filter(node => node.name == \"exit\").code.l res0: List[String] = List(\"exit(0)\", \"exit(42)\") Copy filter steps can be chained together: joern> cpg.call.filter(node => node.name == \"exit\").filter(node => node.code.contains(\"42\")).code.l res0: List[String] = List(\"exit(42)\") Copy And their expression can contain any combination of boolean statements: joern> cpg.call.filter(node => node.name == \"exit\" && node.code.contains(\"42\")).code.l res0: List[String] = List(\"exit(42)\") // equivalent in logic to the query above joern> cpg.call.filter(node => true && 1 == 1 && node.name == \"exit\" && node.code.contains(\"42\")).code.l res0: List[String] = List(\"exit(42)\") Copy One helpful trick is to use the shorthand _ operator in filter expressions, which points to the single argument that is passed into it, that is, the node. // long form joern> cpg.call.filter(node => node.name == \"exit\").code.l res0: List[String] = List(\"exit(0)\", \"exit(42)\") // short form joern> cpg.call.filter(_.name == \"exit\").code.l res1: List[String] = List(\"exit(0)\", \"exit(42)\") Copy "},{"title":"where","type":1,"pageTitle":"Filter Steps","url":"cpgql/filter-steps#where","content":"Just like filter, the where Step is a Filter Step (ಠ~ಠ) which continues a traversal for all nodes which pass its criterion. The expression representing the criterion takes in one argument, a variable that represents the traversal of the previous step, and returns another traversal. Say you'd like to query the Code Property Graph of the X42 program again for all CALL nodes which have exit as the value of their NAME property, and return the value of their CODE property in a list: joern> cpg.call.where(node => node.name(\"exit\")).code.l res0: List[String] = List(\"exit(0)\", \"exit(42)\") // or using the `_` shorthand: joern> cpg.call.where(_.name(\"exit\")).code.l res1: list[string] = list(\"exit(0)\", \"exit(42)\") Copy where's expression supports traversals of any length: joern> cpg.call.where(_.name(\"exit\").argument.code(\"42\")).code.l res0: List[String] = List(\"exit(42)\") Copy And just like where, it supports chaining: // equivalent to the previous query joern> cpg.call.where(_.name(\"exit\")).where(_.argument.code(\"42\")).code.l res0: List[String] = List(\"exit(42)\") Copy "},{"title":"whereNot","type":1,"pageTitle":"Filter Steps","url":"cpgql/filter-steps#wherenot","content":"whereNot is the inverse operation of the where Step. joern> cpg.call.whereNot(_.name(\"exit\")).code.l res0: List[String] = List( \"printf(\\\"What is the meaning of life?\\\\n\\\")\", \"fprintf(stderr, \\\"It depends!\\\\n\\\")\", \"argv[1]\", \"strcmp(argv[1], \\\"42\\\")\", \"strcmp(argv[1], \\\"42\\\") == 0\", \"argc > 1\", \"argc > 1 && strcmp(argv[1], \\\"42\\\") == 0\" ) Copy It supports chaining as well: joern> cpg.call.whereNot(_.name(\"exit\")).whereNot(_.name(\"strcmp\")).code.l res0: List[String] = List( \"printf(\\\"What is the meaning of life?\\\\n\\\")\", \"fprintf(stderr, \\\"It depends!\\\\n\\\")\", \"argv[1]\", \"strcmp(argv[1], \\\"42\\\") == 0\", \"argc > 1\", \"argc > 1 && strcmp(argv[1], \\\"42\\\") == 0\" ) Copy And traversals of any length: joern> cpg.call.whereNot(_.name(\"exit\").argument.code(\"42\")).whereNot(_.name(\"strcmp\")).code.l res0: List[String] = List( \"exit(0)\", \"printf(\\\"What is the meaning of life?\\\\n\\\")\", \"fprintf(stderr, \\\"It depends!\\\\n\\\")\", \"argv[1]\", \"strcmp(argv[1], \\\"42\\\") == 0\", \"argc > 1\", \"argc > 1 && strcmp(argv[1], \\\"42\\\") == 0\" ) Copy "},{"title":"Help Directive","type":0,"sectionRef":"#","url":"cpgql/help-directive","content":"The Help Directive is a CPGQL Directive which returns textual descriptions of other directives. If it is executed by itself, it shows an overview of Top-Level Commands: joern> help res0: Helper = Welcome to the interactive help system. Below you find a table of all available top-level commands. To get more detailed help on a specific command, just type `help.<command>`. Try `help.importCode` to begin with. _______________________________________________________________________________ command | description | example | ==============================================================================| close | Close project by name | close(projectName) | cpg | CPG of the active project | cpg.method.l | delete | Close and remove project from disk | delete(projectName) | importCode | Create new project from code | importCode(\"example.jar\")| importCpg | Create new project from existing CPG| importCpg(\"cpg.bin.zip\") | open | Open project | open(\"projectName\") | project | Currently active project | project | reloadPolicy| reload policy | reloadPolicy | run | Run analyzer on active CPG | run.securityprofile | save | Write all changes to disk | save | undo | undo effects of analyzer | undo | workspace | Access to the workspace directory | workspace | Copy If executed with a Top-Level Command CPGQL Component prefix, it describe that Top-Level Command: joern> help.save res0: String = \"\"\" Close and reopen all loaded CPGs. This ensures that changes have been flushed to disk. Returns list of affected projects\"\"\" Copy","keywords":""},{"title":"Methods","type":0,"sectionRef":"#","url":"cpgql/methods","content":"CPGQL provides several functions for identifying METHOD nodes and similar nodes around it. METHOD nodes are one of the most important nodes in a Code Property Graph. What do METHOD nodes represent exactly? Take the following program written in C: #include <stdio.h> #include <stdlib.h> #include <string.h> int main(int argc, char *argv[]) { if (argc > 1 && strcmp(argv[1], \"42\") == 0) { fprintf(stderr, \"It depends!\\n\"); exit(42); } printf(\"What is the meaning of life?\\n\"); exit(0); } Copy The definition of the main function is of course a node of type METHOD in the Code Property Graph. But, maybe unexpectedly, the Code Property Graph for the program above has 9 nodes of type METHOD. The most important ones are METHOD, METHOD_PARAMETER_IN, METHOD_RETURN, and MODIFIER cpg.method, cpg.methodReturn, cpg.methodRef This article gives an overview of all the Traversal Steps centered around identifying METHOD nodes in a Code Property Graph. The METHOD node itself represents. There are multiple ways of identifying methods using the Joern Shell. note Add text","keywords":""},{"title":"Reference Card","type":0,"sectionRef":"#","url":"cpgql/reference-card","content":"","keywords":""},{"title":"Node-Type Steps","type":1,"pageTitle":"Reference Card","url":"cpgql/reference-card#node-type-steps","content":"Step\tDescriptionall\tAll nodes argument\tAll arguments (actual parameters) call\tAll call sites comment\tAll comments (only source-based CPGs) file\tAll source files identifier\tAll identifiers, e.g. occurrences of local variables or class members in method bodies literal\tAll literals, e.g. numbers or strings local\tAll local variables member\tAll members of complex types, e.g. classes, structs metaData\tThe meta data node method\tAll methods methodRef\tAll method references typeRef\tAll type references methodReturn\tAll formal return paramters namespace\tAll namespaces namespaceBlock\tAll namespace blocks parameter\tAll parameters returns\tAll actual return parameters typeDecl\tAll declarations of types tag\tAll tags types\tAll used types "},{"title":"Core Steps","type":1,"pageTitle":"Reference Card","url":"cpgql/reference-card#core-steps","content":"Step\tDescriptionclone\tCreate a deep copy of the traversal dedup\tDeduplicate results in a traveral map\tTransform the traversal by a given function sideEffect\tExtend the traversal with a side-effect step by applying a function "},{"title":"Filter Steps","type":1,"pageTitle":"Reference Card","url":"cpgql/reference-card#filter-steps","content":"Step\tDescriptionand\tThe and step is a filter with multiple and related filter traversals. filter\tKeep nodes for which the provided predicate returns true filterNot\tKeep nodes for which the provided predicate returns false where\tTraversal proceeds for steps with non-empty returns for the provided predicate whereNot\tTraversal proceeds for steps with empty returns for the provided predicate or\tThe or step is a filter with multiple or related filter traversals. "},{"title":"Repeat Steps","type":1,"pageTitle":"Reference Card","url":"cpgql/reference-card#repeat-steps","content":"Step\tDescriptionrepeat\tRepeat the given traversal. This step can be combined with the until and emit steps to provide a termination and emit criteria. until\tTermination criteria for a repeat step. If used before the repeat step it as \"while\" characteristics. If used after the repeat step it as \"do-while\" characteristics. times\tModifier for repeat steps. Configure the amount of times the repeat traversal is executed. emit\tEmit is used with the repeat step to emit the elements of the repeatTraversal after each iteration of the repeat loop. "},{"title":"Complex Steps","type":1,"pageTitle":"Reference Card","url":"cpgql/reference-card#complex-steps","content":"Step\tDescriptioncallee\tList all nodes representing Call Graph callees of the traversed nodes caller\tList all nodes representing Call Graph callers of the traversed nodes callIn\tList all nodes representing Call Graph parent call-sites of the traversed nodes controlledBy\tReturns only those dataflows that are wrapped by a given AST control condition (>, <, =, etc.) dump\tExecute the traversal and return the CODE property with syntax highlighting dumpRaw\tExecute the traversal and return the CODE property without syntax highlighting inCall\tLists all nodes representing surrounding Call Graph call-sites of the traversed nodes locations\tList of all locations nodes traversed in a given dataflow notControlledBy\tReturns only those flows that are NOT wrapped by a given AST control condition (>, <, =, etc.) passesNot\tReturns only those dataflows that DO NOT pass through a given function/condition as defined in predicate passes\tReturns only those dataflows that pass through a given function/condition as defined in predicate reachableBy\tFind if a given source node is reachable by a sink via a dataflow sink\tList of all nodes identified as potential sensitive sinks the natured of methods, literals, types etc. associated with them source\tList of all nodes identified as sensitive/attacker-controlled due to the natured of methods, literals, types etc. associated with them tagList\tExecute the traversal and return TAG nodes connected to each of the nodes "},{"title":"Execution Directives","type":1,"pageTitle":"Reference Card","url":"cpgql/reference-card#execution-directives","content":"Directive\tDescriptiontoList\tExecute the traversal and convert the result to a list l\tShorthand for toList toJson\tExecute the traversal and convert the result to JSON toJsonPretty\tExecute the traversal and convert the result to prettified JSON p\tExecute the traversal and pretty print the results size\tExecute the traversal and return the size of the array of nodes "},{"title":"Help Directive","type":1,"pageTitle":"Reference Card","url":"cpgql/reference-card#help-directive","content":"Directive\tDescriptionhelp\tPrint help based on the current element type "},{"title":"Augmentation Directives","type":1,"pageTitle":"Reference Card","url":"cpgql/reference-card#augmentation-directives","content":"Directive\tDescriptionnewTagNode\tTag node with a specific name newTagNodePair\tTag node with a specific name and value store\tStore changes in the current DiffGraph "},{"title":"Repeat Steps","type":0,"sectionRef":"#","url":"cpgql/repeat-steps","content":"","keywords":""},{"title":"repeat..times","type":1,"pageTitle":"Repeat Steps","url":"cpgql/repeat-steps#repeattimes","content":"joern> cpg.method.name(\"main\").repeat(_.astChildren)(_.times(4)).l res123: List[AstNode] = List( Call( id -> 13L, code -> \"argc > 1\", name -> \"<operator>.greaterThan\", // ...output trimmed for brevity ), Call( id -> 16L, code -> \"strcmp(argv[1], \\\"42\\\") == 0\", name -> \"<operator>.equals\", // ...output trimmed for brevity ), Call( id -> 24L, code -> \"fprintf(stderr, \\\"It depends!\\\\n\\\")\", name -> \"fprintf\", // ...output trimmed for brevity ), Call( id -> 27L, code -> \"exit(42)\", name -> \"exit\", // ...output trimmed for brevity ) ) Copy "},{"title":"repeat..until","type":1,"pageTitle":"Repeat Steps","url":"cpgql/repeat-steps#repeatuntil","content":"joern> cpg.method.name(\"main\").repeat(_.astChildren)(_.until(_.isCall)).l res124: List[AstNode] = List( Call( id -> 29L, code -> \"printf(\\\"What is the meaning of life?\\\\n\\\")\", name -> \"printf\", // ...output trimmed for brevity ), Call( id -> 31L, code -> \"exit(0)\", name -> \"exit\", // ...output trimmed for brevity ), Call( id -> 12L, code -> \"argc > 1 && strcmp(argv[1], \\\"42\\\") == 0\", name -> \"<operator>.logicalAnd\", // ...output trimmed for brevity ), Call( id -> 24L, code -> \"fprintf(stderr, \\\"It depends!\\\\n\\\")\", name -> \"fprintf\", // ...output trimmed for brevity ), Call( id -> 27L, code -> \"exit(42)\", name -> \"exit\", // ...output trimmed for brevity ) ) Copy joern> cpg.method.name(\"main\").repeat(_.astChildren)(_.until(_.isCall.name(\"exit\"))).l res125: List[AstNode] = List( Call( id -> 31L, code -> \"exit(0)\", name -> \"exit\", // ...output trimmed for brevity ), Call( id -> 27L, code -> \"exit(42)\", name -> \"exit\", // ...output trimmed for brevity ) ) Copy "},{"title":"repeat..emit..times","type":1,"pageTitle":"Repeat Steps","url":"cpgql/repeat-steps#repeatemittimes","content":"joern> cpg.method.name(\"main\").repeat(_.astChildren)(_.emit(_.isControlStructure).times(4)).l res130: List[AstNode] = List( ControlStructure( id -> 11L, code -> \"if (argc > 1 && strcmp(argv[1], \\\"42\\\") == 0)\", // ...output trimmed for brevity ), Call( id -> 13L, code -> \"argc > 1\", name -> \"<operator>.greaterThan\", // ...output trimmed for brevity ), Call( id -> 16L, code -> \"strcmp(argv[1], \\\"42\\\") == 0\", name -> \"<operator>.equals\", // ...output trimmed for brevity ), Call( id -> 24L, code -> \"fprintf(stderr, \\\"It depends!\\\\n\\\")\", name -> \"fprintf\", // ...output trimmed for brevity ), Call( id -> 27L, code -> \"exit(42)\", name -> \"exit\", // ...output trimmed for brevity ) ) Copy "},{"title":"repeat..emit..until","type":1,"pageTitle":"Repeat Steps","url":"cpgql/repeat-steps#repeatemituntil","content":"joern> cpg.method.name(\"main\").repeat(_.astChildren).until(_.isCall).l res124: List[AstNode] = List( Call( id -> 29L, code -> \"printf(\\\"What is the meaning of life?\\\\n\\\")\", name -> \"printf\", // ...output trimmed for brevity ), Call( id -> 31L, code -> \"exit(0)\", name -> \"exit\", // ...output trimmed for brevity ), Call( id -> 12L, code -> \"argc > 1 && strcmp(argv[1], \\\"42\\\") == 0\", name -> \"<operator>.logicalAnd\", // ...output trimmed for brevity ), Call( id -> 24L, code -> \"fprintf(stderr, \\\"It depends!\\\\n\\\")\", name -> \"fprintf\", // ...output trimmed for brevity ), Call( id -> 27L, code -> \"exit(42)\", name -> \"exit\", // ...output trimmed for brevity ) ) Copy "},{"title":"Exporting Graphs","type":0,"sectionRef":"#","url":"exporting","content":"","keywords":""},{"title":"The command line tool joern-export","type":1,"pageTitle":"Exporting Graphs","url":"exporting#the-command-line-tool-joern-export","content":"All of these representations can be plotted and exported into the graphviz dot format to enable processing with third party tools or via external scripts. To parse the code in /src/directory and dump Program Dependence Graphs for all methods into the directory outdir, you can run the following commands on the system shell: joern-parse /src/directory joern-export --repr pdg --out outdir Copy For a complete overview of options, run joern-export --help. "},{"title":"Plotting and Exporting on the Joern Console","type":1,"pageTitle":"Exporting Graphs","url":"exporting#plotting-and-exporting-on-the-joern-console","content":"If you would like to explore graph representations interactively, you can do so on the Joern shell. To this end, we define the following steps on method nodes to dump representations in dot format. cpg.method($name).dotAst.l // output AST in dot format cpg.method($name).dotCfg.l // output CFG in dot format ... cpg.method($name).dotCpg14.l // output CPG'14 in dot format Copy You can also plot and view representations using the following queries: cpg.method($name).plotDotAst // plot AST cpg.method($name).ploDotCfg // plot CFG ... cpg.method($name).plotDotCpg14 // plot CPG'14 Copy Note that the ossdataflow layer needs to have been calculated for the source CPG via run.ossdataflow. "},{"title":"Example","type":1,"pageTitle":"Exporting Graphs","url":"exporting#example","content":"Generate the CPG along with the data flow layer for a sample function named myfunc. joern> importCode.c.fromString( \"\"\" int myfunc(int b) { int a = 42; if (b > 10) { foo(a) } bar(a); } \"\"\" ) joern> run.ossdataflow Copy You can now plot the AST as follows: joern> cpg.method(\"myfunc\").plotDotAst Copy You can obtain the dot representation of the AST as well: joern> cpg.method(\"myfunc\").dotAst.l res4: List[String] = List( \"\"\"digraph myfunc { \"1000102\" [label = \"(METHOD,myfunc)\" ] \"1000103\" [label = \"(PARAM,int b)\" ] \"1000104\" [label = \"(BLOCK,,)\" ] \"1000105\" [label = \"(LOCAL,a: int)\" ] \"1000106\" [label = \"(<operator>.assignment,a = 42)\" ] \"1000107\" [label = \"(IDENTIFIER,a,a = 42)\" ] \"1000108\" [label = \"(LITERAL,42,a = 42)\" ] \"1000109\" [label = \"(CONTROL_STRUCTURE,if (b > 10),if (b > 10))\" ] \"1000110\" [label = \"(<operator>.greaterThan,b > 10)\" ] \"1000111\" [label = \"(IDENTIFIER,b,b > 10)\" ] \"1000112\" [label = \"(LITERAL,10,b > 10)\" ] \"1000113\" [label = \"(BLOCK,,)\" ] \"1000114\" [label = \"(bar,bar(a))\" ] \"1000115\" [label = \"(IDENTIFIER,a,bar(a))\" ] \"1000116\" [label = \"(METHOD_RETURN,int)\" ] \"1000102\" -> \"1000103\" \"1000102\" -> \"1000104\" \"1000102\" -> \"1000116\" \"1000104\" -> \"1000105\" \"1000104\" -> \"1000106\" \"1000104\" -> \"1000109\" \"1000104\" -> \"1000114\" \"1000106\" -> \"1000107\" \"1000106\" -> \"1000108\" \"1000109\" -> \"1000110\" \"1000109\" -> \"1000113\" \"1000110\" -> \"1000111\" \"1000110\" -> \"1000112\" \"1000114\" -> \"1000115\" } \"\"\" ) Copy "},{"title":"Dumping representations for all functions from the shell","type":1,"pageTitle":"Exporting Graphs","url":"exporting#dumping-representations-for-all-functions-from-the-shell","content":"You can also dump all representations into the directory out using run.dumpast run.dumpcfg ... run.dumpcpg14 Copy "},{"title":"References","type":1,"pageTitle":"Exporting Graphs","url":"exporting#references","content":"Research that employs Joern as an extraction tool for intermediate representations of code: (1) Devign: Effective Vulnerability Identification by Learning Comprehensive Program Semantics via Graph Neural Networks, Zhou et al., NIPS'19 (2) Source Code Authorship Attribution using LongShort-Term Memory Based Networks, Alsulami et al., ESORICS'17 (3)VulPecker: an automated vulnerability detection system based on code similarity analysis, Li et al., ACSAC'16 (4) Git blame who?: Stylistic authorship attribution of small, incomplete source code fragments, Dauber et al., PETS-19/3 (5) SPIDER: Enabling Fast Patch Propagation In Related Software Repositories, Machiry et al., S&P'20 "},{"title":"Extending Joern","type":0,"sectionRef":"#","url":"extensions","content":"","keywords":""},{"title":"Installing the sample extension","type":1,"pageTitle":"Extending Joern","url":"extensions#installing-the-sample-extension","content":"We provide a sample extension that you can use as a template. First, make sure that dependencies are installed correctly: Joern is installed in ~/bin/joern (seeInstallation)The Scala Build Tool (SBT) in any version (via your package manager) Next, issue the following commands to install the sample extension. git clone https://github.com/joernio/sample-extension cd sample-extension ./install.sh cd ~/bin/joern/joern-cli ./joern Copy On the joern shell, type run. You should see the extension in the overview:  To run the extension, type run.gitextension. You can also inspect/modify options passed to the plugin by typingopts.gitextension.<TAB>. "},{"title":"Importing into the IntelliJ IDE and running tests","type":1,"pageTitle":"Extending Joern","url":"extensions#importing-into-the-intellij-ide-and-running-tests","content":"Joern Extensions can be developed in an IDE and the process of importing an extension may differ slightly from IDE to IDE. The following instructions are for IntelliJ 2020.1.1. Choose \"Open or Import\" to import the project.  Next, select the directory from the file selector. Assuming that your IntelliJ installation has support for sbt installed, the import is fully automated.  Finally, navigate to src/test/scala/io/shiftleft/gitextension and click on GitextentionTests. You can right-click on the class or the individual tests to run them.  "},{"title":"Adding dependencies","type":1,"pageTitle":"Extending Joern","url":"extensions#adding-dependencies","content":"You can add dependencies by modifying the variablelibraryDependencies in build.sbt: // build.sbt name := \"joern-sample-extension\" ThisBuild/organization := \"io.joern\" ThisBuild/scalaVersion := \"2.13.0\" ... libraryDependencies ++= Seq( // Add your dependencies here \"org.eclipse.jgit\" % \"org.eclipse.jgit\" % \"5.7.0.202003110725-r\", // ... \"org.scalatest\" %% \"scalatest\" % \"3.1.1\" % Test ) ... Copy If the dependency is not shipped with joern, please also make sure to copy it to joern's lib directory on installation by editinginstall.sh. (We may have already automated this step at the time of reading): // install.sh ... echo \"Installing jars into: ${JAR_INSTALL_DIR}\" cp target/universal/stage/lib/io.joern.joern-sample-extension-*.jar ${JAR_INSTALL_DIR} cp target/universal/stage/lib/org.eclipse.jgit.org.eclipse.jgit* ${JAR_INSTALL_DIR} // Copy any jars you need to be installed for the plugin into $JAR_INSTALL_DIR cp target/universal/stage/lib/... ${JAR_INSTALL_DIR} ... Copy "},{"title":"Extending the CPG schema","type":1,"pageTitle":"Extending Joern","url":"extensions#extending-the-cpg-schema","content":"You can make additions to the CPG schema specification by placing.json files in schema/src/main/resources/schema/. A sample schema extension is provided that adds an edge of type \"FOO\" that is valid from FILE nodes to METHOD nodes. schema/src/main/resources/schema/ext.json { \"edgeTypes\" : [ {\"id\" : 9000, \"name\": \"FOO\", \"comment\" : \"Foo edge\", \"keys\": []} ], \"nodeTypes\" : [ { \"name\" : \"FILE\", \"outEdges\" : [{\"edgeName\": \"FOO\", \"inNodes\": [{\"name\": \"METHOD\"}]}] } ] } Copy "},{"title":"Node-Type Steps","type":0,"sectionRef":"#","url":"cpgql/node-type-steps","content":"","keywords":""},{"title":"Overview","type":1,"pageTitle":"Node-Type Steps","url":"cpgql/node-type-steps#overview","content":"Step\tDescriptionall\tVisits all nodes in the Code Property Graph block\tVisits BLOCK nodes call\tVisits CALL nodes; represent call-sites comment\tVisits COMMENT nodes; COMMENT nodes exist only for source-based Code Propert Graphs file\tVisits FILE nodes; in source-based Code Property Graphs, FILE nodes will point both to the actual source code files of the program under analysis and paths to the referenced files from the standard library, for IR-based Code Property Graphs, the nodes representing source code files will not exist identifier\tVisits IDENTIFIER nodes; e.g. occurrences of local variables or class members in method bodies literal\tVisits LITERAL nodes; e.g. numbers or strings local\tVisits LOCAL nodes; represent local variable member\tVisits MEMBER nodes; MEMBER nodes refer to members of complex types like classes or structs metaData\tVisits the META_DATA node method\tVisits METHOD nodes methodRef\tVisits METHOD_REF nodes methodReturn\tVisits METHOD_RETURN nodes; all formal return parameters modifier\tVisits MODIFIER nodes; e.g. public, private, static namespace\tVisits NAMESPACE nodes namespaceBlock\tVisits NAMESPACE_BLOCK nodes parameter\tVisits PARAMETER nodes returns\tVisits RETURN nodes typeDecl\tVisits TYPE_DECL nodes tag\tVisits TAG nodes typ\tVisits TYPE nodes "},{"title":"all","type":1,"pageTitle":"Node-Type Steps","url":"cpgql/node-type-steps#all","content":"The all Node-Type Step represents a traversal which visits all nodes of a Code Property Graph. It supports the two only Property Directives which are common to all Node-Type Steps, id and label. Supported Property Directives Property Directive\tReturn Type\tDescriptionid\tint\tUnique node identifier label\tstring\tReturns the value of the LABEL property which represents the node type Supported Node Type Steps Node Type Step\tDescriptionfile\tVisits FILE nodes attached to all nodes in the graph tag\tVisits TAG nodes attached to all nodes in the graph Supported Complex Steps None. "},{"title":"block","type":1,"pageTitle":"Node-Type Steps","url":"cpgql/node-type-steps#block","content":"Supported Property Directives Property Directive\tReturn Type\tDescriptionargumentIndex\tint\tIdentifies different AST children of CALL nodes or BLOCK nodes. Ordered 1 to N, with 0 reserved for implicit arguments like this or self id\tint\tUnique node identifier label\tstring\tReturns the value of the LABEL property which represents the node type lineNumber\tint\tFirst line at which the code representing this node is found order\tint\tGeneral ordering property for AST nodes Supported Node Type Steps Node Type Step\tDescriptioncall\tVisits CALL nodes; represent call-sites file\tVisits FILE nodes; in source-based Code Property Graphs, FILE nodes will point both to the actual source code files of the program under analysis and paths to the referenced files from the standard library, for IR-based Code Property Graphs, the nodes representing source code files will not exist local\tVisits LOCAL nodes; represent local variable tag\tVisits TAG nodes typ\tVisits TYPE nodes Supported Complex Steps Complex Step\tDescriptionlocation\tTODO "},{"title":"call","type":1,"pageTitle":"Node-Type Steps","url":"cpgql/node-type-steps#call","content":"Supported Property Directives Property Directive\tReturn Type\tDescriptioncode\tstring\tThe source code construct this node represents id\tint\tUnique node identifier label\tstring\tReturns the value of the LABEL property which represents the node type lineNumber\tint\tFirst line at which the code representing this node is found name\tstring\tGeneral string identifier for various nodes Supported Node Type Steps Node Type Step\tDescriptioncall\tVisits CALL nodes; represent call-sites file\tVisits FILE nodes; in source-based Code Property Graphs, FILE nodes will point both to the actual source code files of the program under analysis and paths to the referenced files from the standard library, for IR-based Code Property Graphs, the nodes representing source code files will not exist method\tVisits METHOD nodes parameter\tVisits PARAMETER nodes tag\tVisits TAG nodes Supported Complex Steps Complex Step\tDescriptionargument\tVisits nodes connected by ARGUMENT edges; actual parameters isDynamic\tTODO isStatic\tTODO location\tTODO "},{"title":"comment","type":1,"pageTitle":"Node-Type Steps","url":"cpgql/node-type-steps#comment","content":"Supported Property Directives Property Directive\tReturn Type\tDescriptionid\tint\tUnique node identifier code\tstring\tThe source code construct this node represents label\tstring\tReturns the value of the LABEL property which represents the node type lineNumber\tint\tFirst line at which the code representing this node is found Supported Node Type Steps Node Type Step\tDescriptionfile\tVisits FILE nodes; in source-based Code Property Graphs, FILE nodes will point both to the actual source code files of the program under analysis and paths to the referenced files from the standard library, for IR-based Code Property Graphs, the nodes representing source code files will not exist tag\tVisits TAG nodes Supported Complex Steps Complex Step\tDescriptionlocation\tTODO location\tTODO "},{"title":"file","type":1,"pageTitle":"Node-Type Steps","url":"cpgql/node-type-steps#file","content":"Supported Property Directives Property Directive\tReturn Type\tDescriptionid\tint\tUnique node identifier label\tstring\tReturns the value of the LABEL property which represents the node type name\tstring\tGeneral string identifier for various nodes order\tint\tGeneral ordering property for AST nodes Supported Node Type Steps Node Type Step\tDescriptionfile\tVisits FILE nodes; in source-based Code Property Graphs, FILE nodes will point both to the actual source code files of the program under analysis and paths to the referenced files from the standard library, for IR-based Code Property Graphs, the nodes representing source code files will not exist namespace\tVisits NAMESPACE nodes namespaceBlock\tVisits NAMESPACE_BLOCK nodes tag\tVisits TAG nodes typeDecl\tVisits TYPE_DECL nodes Supported Complex Steps Complex Step\tDescriptionlocation\tTODO location\tTODO "},{"title":"identifier","type":1,"pageTitle":"Node-Type Steps","url":"cpgql/node-type-steps#identifier","content":"Supported Property Directives Property Directive\tReturn Type\tDescriptioncode\tstring\tThe source code construct this node represents id\tint\tUnique node identifier label\tstring\tReturns the value of the LABEL property which represents the node type lineNumber\tint\tFirst line at which the code representing this node is found name\tstring\tGeneral string identifier for various nodes order\tint\tGeneral ordering property for AST nodes Supported Node Type Steps Node Type Step\tDescriptionfile\tVisits FILE nodes; in source-based Code Property Graphs, FILE nodes will point both to the actual source code files of the program under analysis and paths to the referenced files from the standard library, for IR-based Code Property Graphs, the nodes representing source code files will not exist parameter\tVisits PARAMETER nodes tag\tVisits TAG nodes typ\tVisits TYPE nodes Supported Complex Steps Complex Step\tDescriptionlocation\tTODO location\tTODO "},{"title":"literal","type":1,"pageTitle":"Node-Type Steps","url":"cpgql/node-type-steps#literal","content":"Supported Property Directives Property Directive\tReturn Type\tDescriptioncode\tstring\tThe source code construct this node represents id\tint\tUnique node identifier label\tstring\tReturns the value of the LABEL property which represents the node type lineNumber\tint\tFirst line at which the code representing this node is found order\tint\tGeneral ordering property for AST nodes Supported Node Type Steps Node Type Step\tDescriptioncall\tVisits CALL nodes; represent call-sites file\tVisits FILE nodes; in source-based Code Property Graphs, FILE nodes will point both to the actual source code files of the program under analysis and paths to the referenced files from the standard library, for IR-based Code Property Graphs, the nodes representing source code files will not exist method\tVisits METHOD nodes parameter\tVisits PARAMETER nodes tag\tVisits TAG nodes typ\tVisits TYPE nodes Supported Complex Steps Complex Step\tDescriptionlocation\tTODO "},{"title":"local","type":1,"pageTitle":"Node-Type Steps","url":"cpgql/node-type-steps#local","content":"Supported Property Directives Property Directive\tReturn Type\tDescriptioncode\tstring\tThe source code construct this node represents id\tint\tUnique node identifier label\tstring\tReturns the value of the LABEL property which represents the node type lineNumber\tint\tFirst line at which the code representing this node is found name\tstring\tGeneral string identifier for various nodes order\tint\tGeneral ordering property for AST nodes Supported Node Type Steps Node Type Step\tDescriptionfile\tVisits FILE nodes; in source-based Code Property Graphs, FILE nodes will point both to the actual source code files of the program under analysis and paths to the referenced files from the standard library, for IR-based Code Property Graphs, the nodes representing source code files will not exist tag\tVisits TAG nodes typ\tVisits TYPE nodes Supported Complex Steps Complex Step\tDescriptionlocation\tTODO location\tTODO "},{"title":"member","type":1,"pageTitle":"Node-Type Steps","url":"cpgql/node-type-steps#member","content":"Supported Property Directives Property Directive\tReturn Type\tDescriptioncode\tstring\tThe source code construct this node represents id\tint\tUnique node identifier label\tstring\tReturns the value of the LABEL property which represents the node type name\tstring\tGeneral string identifier for various nodes order\tint\tGeneral ordering property for AST nodes Supported Node Type Steps Node Type Step\tDescriptionfile\tVisits FILE nodes; in source-based Code Property Graphs, FILE nodes will point both to the actual source code files of the program under analysis and paths to the referenced files from the standard library, for IR-based Code Property Graphs, the nodes representing source code files will not exist modifier\tVisits MODIFIER nodes; e.g. public, private, static tag\tVisits TAG nodes typ\tVisits TYPE nodes typeDecl\tVisits TYPE_DECL nodes Supported Complex Steps Complex Step\tDescriptionlocation\tTODO "},{"title":"metaData","type":1,"pageTitle":"Node-Type Steps","url":"cpgql/node-type-steps#metadata","content":"Supported Property Directives Property Directive\tReturn Type\tDescriptionid\tint\tUnique node identifier label\tstring\tReturns the value of the LABEL property which represents the node type language\tstring\tThe programming language this graph originates from version\tstring\tA version, given as a string Supported Node Type Steps Node Type Step\tDescriptiontag\tVisits TAG nodes file\tVisits FILE nodes; in source-based Code Property Graphs, FILE nodes will point both to the actual source code files of the program under analysis and paths to the referenced files from the standard library, for IR-based Code Property Graphs, the nodes representing source code files will not exist Supported Complex Steps Complex Step\tDescriptionlocation\tTODO "},{"title":"method","type":1,"pageTitle":"Node-Type Steps","url":"cpgql/node-type-steps#method","content":"Supported Property Directives Property Directive\tReturn Type\tDescriptionfullName\tstring\tGeneral string identifier which includes various details of the node it is defined on id\tint\tUnique node identifier isExternal\tboolean\tIndicates that the node represents a program construct that is not defined directly in its source code label\tstring\tReturns the value of the LABEL property which represents the node type lineNumber\tint\tFirst line at which the code representing this node is found lineNumberEnd\tint\tLast line at which the code representing this node is found name\tstring\tGeneral string identifier for various nodes order\tint\tGeneral ordering property for AST nodes signature\tstring\tThe method signature; usually includes the method name, and the number, types and order of its parameters Supported Node Type Steps Node Type Step\tDescriptionlocal\tVisits LOCAL nodes; represent local variable method\tVisits METHOD nodes methodReturn\tVisits METHOD_RETURN nodes; all formal return parameters modifier\tVisits MODIFIER nodes; e.g. public, private, static namespace\tVisits NAMESPACE nodes parameter\tVisits PARAMETER nodes tag\tVisit TAG nodes attached to the METHOD nodes; that is, tags found on methods Supported Complex Steps Complex Step\tDescriptionisPrivate\tFilter for the METHOD nodes which are connected to MODIFIER nodes with the modifierType property set to PRIVATE isProtected\tFilter for the METHOD nodes which are connected to MODIFIER nodes with the modifierType property set to PROTECTED isPublic\tFilter for the METHOD nodes which are connected to MODIFIER nodes with the modifierType property set to PUBLIC isStatic\tFilter for the METHOD nodes which are connected to MODIFIER nodes with the modifierType property set to STATIC isVirtual\tFilter for the METHOD nodes which are connected to MODIFIER nodes with the modifierType property set to VIRTUAL location\tTODO "},{"title":"methodRef","type":1,"pageTitle":"Node-Type Steps","url":"cpgql/node-type-steps#methodref","content":"Supported Property Directives Property Directive\tReturn Type\tDescriptioncode\tstring\tThe source code construct this node represents id\tint\tUnique node identifier label\tstring\tReturns the value of the LABEL property which represents the node type lineNumber\tint\tFirst line at which the code representing this node is found order\tint\tGeneral ordering property for AST nodes Supported Node Type Steps Node Type Step\tDescriptionfile\tVisits FILE nodes; in source-based Code Property Graphs, FILE nodes will point both to the actual source code files of the program under analysis and paths to the referenced files from the standard library, for IR-based Code Property Graphs, the nodes representing source code files will not exist method\tVisits METHOD nodes parameter\tVisits PARAMETER nodes tag\tVisits TAG nodes typ\tVisits TYPE nodes Supported Complex Steps Complex Step\tDescriptionlocation\tTODO "},{"title":"methodReturn","type":1,"pageTitle":"Node-Type Steps","url":"cpgql/node-type-steps#methodreturn","content":"Supported Property Directives Property Directive\tReturn Type\tDescriptioncode\tstring\tThe source code construct this node represents id\tint\tUnique node identifier label\tstring\tReturns the value of the LABEL property which represents the node type lineNumber\tint\tFirst line at which the code representing this node is found order\tint\tGeneral ordering property for AST nodes Supported Node Type Steps Node Type Step\tDescriptionfile\tVisits FILE nodes; in source-based Code Property Graphs, FILE nodes will point both to the actual source code files of the program under analysis and paths to the referenced files from the standard library, for IR-based Code Property Graphs, the nodes representing source code files will not exist method\tVisits METHOD nodes tag\tVisits TAG nodes typ\tVisits TYPE nodes Supported Complex Steps Complex Step\tDescriptionlocation\tTODO "},{"title":"modifier","type":1,"pageTitle":"Node-Type Steps","url":"cpgql/node-type-steps#modifier","content":"Supported Property Directives Property Directive\tReturn Type\tDescriptionid\tint\tUnique node identifier label\tstring\tReturns the value of the LABEL property which represents the node type order\tint\tGeneral ordering property for AST nodes Supported Node Type Steps Node Type Step\tDescriptionfile\tVisits FILE nodes; in source-based Code Property Graphs, FILE nodes will point both to the actual source code files of the program under analysis and paths to the referenced files from the standard library, for IR-based Code Property Graphs, the nodes representing source code files will not exist tag\tVisits TAG nodes Supported Complex Steps Complex Step\tDescriptionlocation\tTODO "},{"title":"namespaceBlock","type":1,"pageTitle":"Node-Type Steps","url":"cpgql/node-type-steps#namespaceblock","content":"Supported Property Directives Property Directive\tReturn Type\tDescriptionid\tint\tUnique node identifier fullName\tstring\tGeneral string identifier which includes various details of the node it is defined on label\tstring\tReturns the value of the LABEL property which represents the node type name\tstring\tGeneral string identifier for various nodes order\tint\tGeneral ordering property for AST nodes Supported Node Type Steps Node Type Step\tDescriptionfile\tVisits FILE nodes; in source-based Code Property Graphs, FILE nodes will point both to the actual source code files of the program under analysis and paths to the referenced files from the standard library, for IR-based Code Property Graphs, the nodes representing source code files will not exist tag\tVisits TAG nodes typeDecl\tVisits TYPE_DECL nodes Supported Complex Steps Complex Step\tDescriptionlocation\tTODO "},{"title":"namespace","type":1,"pageTitle":"Node-Type Steps","url":"cpgql/node-type-steps#namespace","content":"Supported Property Directives Property Directive\tReturn Type\tDescriptionid\tint\tUnique node identifier label\tstring\tReturns the value of the LABEL property which represents the node type name\tstring\tGeneral string identifier for various nodes order\tint\tGeneral ordering property for AST nodes Supported Node Type Steps Node Type Step\tDescriptionfile\tVisits FILE nodes; in source-based Code Property Graphs, FILE nodes will point both to the actual source code files of the program under analysis and paths to the referenced files from the standard library, for IR-based Code Property Graphs, the nodes representing source code files will not exist tag\tVisits TAG nodes typeDecl\tVisits TYPE_DECL nodes Supported Complex Steps Complex Step\tDescriptionlocation\tTODO "},{"title":"parameter","type":1,"pageTitle":"Node-Type Steps","url":"cpgql/node-type-steps#parameter","content":"Supported Property Directives Property Directive\tReturn Type\tDescriptioncode\tstring\tThe source code construct this node represents id\tint\tUnique node identifier label\tstring\tReturns the value of the LABEL property which represents the node type lineNumber\tint\tFirst line at which the code representing this node is found name\tstring\tGeneral string identifier for various nodes order\tint\tGeneral ordering property for AST nodes Supported Node Type Steps Node Type Step\tDescriptionfile\tVisits FILE nodes; in source-based Code Property Graphs, FILE nodes will point both to the actual source code files of the program under analysis and paths to the referenced files from the standard library, for IR-based Code Property Graphs, the nodes representing source code files will not exist method\tVisits METHOD nodes tag\tVisits TAG nodes typ\tVisits TYPE nodes Supported Complex Steps Complex Step\tDescriptionlocation\tTODO "},{"title":"returns","type":1,"pageTitle":"Node-Type Steps","url":"cpgql/node-type-steps#returns","content":"Supported Property Directives Property Directive\tReturn Type\tDescriptioncode\tstring\tThe source code construct this node represents id\tint\tUnique node identifier label\tstring\tReturns the value of the LABEL property which represents the node type lineNumber\tint\tFirst line at which the code representing this node is found order\tint\tGeneral ordering property for AST nodes Supported Node Type Steps Node Type Step\tDescriptioncall\tVisits CALL nodes; represent call-sites file\tVisits FILE nodes; in source-based Code Property Graphs, FILE nodes will point both to the actual source code files of the program under analysis and paths to the referenced files from the standard library, for IR-based Code Property Graphs, the nodes representing source code files will not exist method\tVisits METHOD nodes parameter\tVisits PARAMETER nodes tag\tVisits TAG nodes Supported Complex Steps Complex Step\tDescriptionlocation\tTODO "},{"title":"tag","type":1,"pageTitle":"Node-Type Steps","url":"cpgql/node-type-steps#tag","content":"Supported Property Directives Property Directive\tReturn Type\tDescriptionid\tint\tUnique node identifier label\tstring\tReturns the value of the LABEL property which represents the node type name\tstring\tGeneral string identifier for various nodes value\tstring\tGeneric string value container Supported Node Type Steps Node Type Step\tDescriptioncall\tVisits CALL nodes attached to the TAG nodes file\tVisits FILE nodes attached to the TAG nodes literal\tVisits LITERAL nodes attached to the TAG nodes local\tVisits LOCAL nodes attached to the TAG nodes method\tVisits METHOD nodes attached to the TAG nodes methodReturn\tVisits METHOD_RETURN nodes attached to the TAG nodes parameter\tVisits PARAMETER nodes attached to the TAG nodes tag\tVisits TAG nodes attached to the TAG nodes Supported Complex Steps Complex Step\tDescriptionlocation\tTODO "},{"title":"typeDecl","type":1,"pageTitle":"Node-Type Steps","url":"cpgql/node-type-steps#typedecl","content":"Supported Property Directives Property Directive\tReturn Type\tDescriptionfullName\tstring\tGeneral string identifier which includes various details of the node it is defined on id\tint\tUnique node identifier isExternal\tboolean\tIndicates that the node represents a program construct that is not defined directly in its source code label\tstring\tReturns the value of the LABEL property which represents the node type name\tstring\tGeneral string identifier for various nodes order\tint\tGeneral ordering property for AST nodes Supported Node Type Steps Node Type Step\tDescriptionfile\tVisits FILE nodes; in source-based Code Property Graphs, FILE nodes will point both to the actual source code files of the program under analysis and paths to the referenced files from the standard library, for IR-based Code Property Graphs, the nodes representing source code files will not exist member\tVisits MEMBER nodes; MEMBER nodes refer to members of complex types like classes or structs method\tVisits METHOD nodes modifier\tVisits MODIFIER nodes; e.g. public, private, static namespace\tVisits NAMESPACE nodes tag\tVisits TAG nodes Supported Complex Steps Complex Step\tDescriptionmethodBinding\tTODO aliasTypeDecl\tTODO aliasTypeDeclTransitive\tTODO baseType\tTODO baseTypeDecl\tTODO baseTypeDeclTransitive\tTODO derivedTypeDecl\tTODO derivedTypeDeclTransitive\tTODO location\tTODO "},{"title":"typ","type":1,"pageTitle":"Node-Type Steps","url":"cpgql/node-type-steps#typ","content":"Supported Property Directives Property Directive\tReturn Type\tDescriptionfullName\tstring\tGeneral string identifier which includes various details of the node it is defined on id\tint\tUnique node identifier label\tstring\tReturns the value of the LABEL property which represents the node type name\tstring\tGeneral string identifier for various nodes Supported Node Type Steps Node Type Step\tDescriptionfile\tVisits FILE nodes; in source-based Code Property Graphs, FILE nodes will point both to the actual source code files of the program under analysis and paths to the referenced files from the standard library, for IR-based Code Property Graphs, the nodes representing source code files will not exist method\tVisits METHOD nodes member\tVisits MEMBER nodes; MEMBER nodes refer to members of complex types like classes or structs parameter\tVisits PARAMETER nodes tag\tVisits TAG nodes Supported Complex Steps Complex Step\tDescriptionaliasType\tTODO aliasTypeDecl\tTODO aliasTypeTransitive\tTODO baseType\tTODO baseTypeTransitive\tTODO derivedType\tTODO derivedTypeDecl\tTODO derivedTypeTransitive\tTODO location\tTODO referencedTypeDecl\tTODO "},{"title":"Glossary","type":0,"sectionRef":"#","url":"glossary","content":"","keywords":""},{"title":"Augmentation","type":1,"pageTitle":"Glossary","url":"glossary#augmentation","content":"An Augmentation is an operation by which a Code Property Graph is extended with nodes, properties and edges. "},{"title":"Augmentation Directive","type":1,"pageTitle":"Glossary","url":"glossary#augmentation-directive","content":"CPGQL Augmentation Directives are Directives which extend a Code Property Graph with nodes, properties and edges. "},{"title":"Call Site","type":1,"pageTitle":"Glossary","url":"glossary#call-site","content":"Location in a Program Structure where a function or subroutine is called. "},{"title":"Code Property Graph","type":1,"pageTitle":"Glossary","url":"glossary#code-property-graph","content":"Data structure designed for vulnerability discovery. A directed, edge-labeled, attributed multigraph, or property graph for short. "},{"title":"Code Property Graph Overlay","type":1,"pageTitle":"Glossary","url":"glossary#code-property-graph-overlay","content":"A set of Nodes, Node Properties and Edges grouped together based on certain criteria. For example, the Dataflow Overlay is the set of Nodes, Node Properties and Edges that are grouped together to represent Dataflows in a Code Property Graph. "},{"title":"Code Property Graph Query Language","type":1,"pageTitle":"Glossary","url":"glossary#code-property-graph-query-language","content":"A domain-specific language designed for querying Code Property Graphs. "},{"title":"Complex Step","type":1,"pageTitle":"Glossary","url":"glossary#complex-step","content":"CPGQL Complex Steps are Step which combine the functionality of one or more Node-Type Steps, Repeat Steps, Filter Steps, Core Steps or Execution Directives. They are represented by one or more Directives. "},{"title":"Core Step","type":1,"pageTitle":"Glossary","url":"glossary#core-step","content":"CPGQL Core Steps are Steps which can be combined with any other Step. They are represented by one or more Directives. "},{"title":"Dataflow","type":1,"pageTitle":"Glossary","url":"glossary#dataflow","content":"A dataflow represents paths information can take from an external input of a program to an internal procedure. "},{"title":"Dataflow Sink","type":1,"pageTitle":"Glossary","url":"glossary#dataflow-sink","content":"The information consumer in a Dataflow, i.e. an internal procedure of a program. "},{"title":"Dataflow Source","type":1,"pageTitle":"Glossary","url":"glossary#dataflow-source","content":"The information generator in a Dataflow, i.e. the input of a program. "},{"title":"Dataflow Step","type":1,"pageTitle":"Glossary","url":"glossary#dataflow-step","content":"An atomic traversal on Nodes and Edges that are part of the Dataflow Overlay. "},{"title":"Dataflow Overlay","type":1,"pageTitle":"Glossary","url":"glossary#dataflow-overlay","content":"The set of Nodes, Node Properties and Edges that represent Dataflows in a Code Property Graph. "},{"title":"Dependency","type":1,"pageTitle":"Glossary","url":"glossary#dependency","content":"External program code that is used in another program. "},{"title":"Directive","type":1,"pageTitle":"Glossary","url":"glossary#directive","content":"CPGQL Directives are keywords of the Code Property Graph Query Language. "},{"title":"Entry Directive","type":1,"pageTitle":"Glossary","url":"glossary#entry-directive","content":"A CPGQL Entry Directive is a Directive which references the entry node of a Code Property Graph. "},{"title":"Execution Directive","type":1,"pageTitle":"Glossary","url":"glossary#execution-directive","content":"CPGQL Execution Directives are Directives which execute the traversals they suffix and return the result in a specific format. "},{"title":"Filter Step","type":1,"pageTitle":"Glossary","url":"glossary#filter-step","content":"CPGQL Filter Steps are Steps which filter nodes in a traversal according to a criterion. They are represented by one or more Directives. "},{"title":"Help Directive","type":1,"pageTitle":"Glossary","url":"glossary#help-directive","content":"The CPGQL Help Directive is a Directive which returns textual descriptions of other directives. "},{"title":"Language Frontend","type":1,"pageTitle":"Glossary","url":"glossary#language-frontend","content":"Joern component that generates Code Property Graphs from a program's source. "},{"title":"Node, Edge, Graph","type":1,"pageTitle":"Glossary","url":"glossary#node-edge-graph","content":"A Code Property Graph is a graph, that is, all objects are represented as nodes and their relationships are represented by edges. Objects represented by nodes are, e.g., files, methods, expressions, and even dataflows. "},{"title":"Node Property","type":1,"pageTitle":"Glossary","url":"glossary#node-property","content":"A key-value pair attached to a Node. "},{"title":"Node Type","type":1,"pageTitle":"Glossary","url":"glossary#node-type","content":"A label that defines the set of mandatory and optional Node Properties and Edges for a specific Node. "},{"title":"Node-Type Step","type":1,"pageTitle":"Glossary","url":"glossary#node-type-step","content":"CPGQL Node-Type Steps are Steps that traverse nodes based on their type. They are represented by a single Directive. "},{"title":"Query","type":1,"pageTitle":"Glossary","url":"glossary#query","content":"A CPGQL Query is a combination of more than two Directives. "},{"title":"Policy","type":1,"pageTitle":"Glossary","url":"glossary#policy","content":"A set of valid Policy Language instructions. "},{"title":"Policy File","type":1,"pageTitle":"Glossary","url":"glossary#policy-file","content":"A textual representation of Policy Language instructions. "},{"title":"Policy Language","type":1,"pageTitle":"Glossary","url":"glossary#policy-language","content":"A domain-specific language which contains directives for extending and modifying Code Property Graphs. "},{"title":"Program Code","type":1,"pageTitle":"Glossary","url":"glossary#program-code","content":"Source representation of a program. Can be a directory with multiple source files, a jar file containing Java Bytecode, an LLVM IR binary or anything similar. "},{"title":"Program Structure","type":1,"pageTitle":"Glossary","url":"glossary#program-structure","content":"The overall form of a computer program which represents its control flow and data structures. "},{"title":"Repeat Step","type":1,"pageTitle":"Glossary","url":"glossary#repeat-step","content":"CPGQL Repeat Steps are Steps which repeat another traversal multiple times. They are represented by one or more Directives. "},{"title":"Script","type":1,"pageTitle":"Glossary","url":"glossary#script","content":"A file containing instructions for Joern to execute. "},{"title":"Semantic Overlay","type":1,"pageTitle":"Glossary","url":"glossary#semantic-overlay","content":"The set of Nodes, Node Properties and Edges that represent Program Structure in a Code Property Graph. "},{"title":"Security Profile","type":1,"pageTitle":"Glossary","url":"glossary#security-profile","content":"A Code Property Graph Overlay comprised of Nodes that hold information about Security Vulnerabilities in the program represented. "},{"title":"Step","type":1,"pageTitle":"Glossary","url":"glossary#step","content":"CPGQL Steps are combinations of one or more Directives that describe graph traversals in the Code Property Graph Query Language. They are represented by one or more Directives. "},{"title":"Tagging Overlay","type":1,"pageTitle":"Glossary","url":"glossary#tagging-overlay","content":"The set of Nodes, Node Properties and Edges of a Code Property Graph that make up for a higher-level abstract representation of Program Structure. "},{"title":"Transformation","type":1,"pageTitle":"Glossary","url":"glossary#transformation","content":"A Transformation is an operation by which a Code Property Graph is generated from Program Code. "},{"title":"Traversal","type":1,"pageTitle":"Glossary","url":"glossary#traversal","content":"A recipe which, given a set of start nodes, describes a walk in the graph to reach a set of end nodes. "},{"title":"Overview","type":0,"sectionRef":"#","url":"home","content":"Welcome to the documentation of the code analysis platform Joern! For a high-level overview, please also check out https://joern.io . Joern is a platform for robust analysis of C/C++ code. It generates code property graphs, a graph representation of code for cross-language code analysis. Code property graphs are stored in a custom graph database. This allows code to be mined using search queries formulated in a Scala-based domain-specific query language. Joern is developed with the goal of providing a useful tool for vulnerability discovery and research in static program analysis. The core features of Joern are: Fuzzy Parsing of C/C++. Joern employs a fuzzy parser for C/C++ based on the concept of Island grammars. The parser enables importing arbitrary code even if a working build environment cannot be supplied or parts of the code are missing. Code Property Graphs. Joern creates semantic code property graphs from the fuzzy parser output and stores them in an in-memory graph database. SCPGs are a language-agnostic intermediate representation of code designed for query-based code analysis. Search Queries. Joern offers a stronly-typed Scala-based extensible query language for code analysis based on Gremlin-Scala. This language can be used to manually formulate search queries for vulnerabilities as well as automatically infer them using machine learning techniques. Extendable via CPG passes. Code property graphs are multi-layered, offering information about code on different levels of abstraction. Joern comes with many default passes, but also allows users to add passes to include additional information in the graph, and extend the query language accordingly.","keywords":""},{"title":"Interpreter","type":0,"sectionRef":"#","url":"interpreter","content":"","keywords":""},{"title":"Installation","type":0,"sectionRef":"#","url":"installation","content":"","keywords":""},{"title":"Prerequisites","type":1,"pageTitle":"Installation","url":"installation#prerequisites","content":"Java 8 or higher Link: https://openjdk.java.net/install/ "},{"title":"Installing Pre-Built Binaries","type":1,"pageTitle":"Installation","url":"installation#installing-pre-built-binaries","content":"Pre-built binaries of the joern-cli are available at: https://github.com/ShiftLeftSecurity/joern/releases/ To install the latest release, simply execute the following git clone https://github.com/ShiftLeftSecurity/joern cd joern ./joern-install.sh Copy and follow the installer instructions. By default, joern will be installed at ~/bin/joern. You can test your installation as follows: cd ~/bin/joern/joern-cli ./joern Compiling (synthetic)/ammonite/predef/interpBridge.sc Compiling (synthetic)/ammonite/predef/replBridge.sc Compiling (synthetic)/ammonite/predef/DefaultPredef.sc Compiling /home/tmp/shiftleft/joern/(console) ██╗ ██████╗ ███████╗██████╗ ███╗ ██╗ ██║██╔═══██╗██╔════╝██╔══██╗████╗ ██║ ██║██║ ██║█████╗ ██████╔╝██╔██╗ ██║ ██ ██║██║ ██║██╔══╝ ██╔══██╗██║╚██╗██║ ╚█████╔╝╚██████╔╝███████╗██║ ██║██║ ╚████║ ╚════╝ ╚═════╝ ╚══════╝╚═╝ ╚═╝╚═╝ ╚═══╝ joern> Copy "},{"title":"Building from Source Code","type":1,"pageTitle":"Installation","url":"installation#building-from-source-code","content":"To build joern-cli from source code, you need to install the Scala build tool (sbt), which you can install by following the instructions at https://www.scala-sbt.org/download.html. Any 1.x version of sbt works as sbt downloads the correct version for building joern as part of the build process. If you are building Joern using macOS you will need to install the greadlink package: brew install coreutils Copy Once the dependencies are installed, run git clone https://github.com/ShiftLeftSecurity/joern.git cd joern sbt stage Copy This builds joern-cli in the current directory. To build the distribution zip file (joern-cli.zip), run sbt createDistribution. "},{"title":"Configuring the JVM for Optimal Performance","type":1,"pageTitle":"Installation","url":"installation#configuring-the-jvm-for-optimal-performance","content":"Code analysis can require lots of memory, and unfortunately, the JVM does not pick up the available amount of memory by itself. While tuning Java memory usage is a discipline in its own right, it is usually sufficient to specify the maximum available amount of heap memory using the JVM's -Xmx flag. The easiest way to achieve this globally is by setting the environment variable _JAVA_OPTS as follows: export _JAVA_OPTS=\"-Xmx$NG\" Copy where $N is the amount of memory in gigabytes. For example, to allow the JVM to use 20 gigabytes of RAM, you would issue the following: export _JAVA_OPTS=\"-Xmx20G\" Copy You can add this line to your shell startup script, e.g., ~/.bashrc or ~/.zshrc. "},{"title":"Basic Usage","type":1,"pageTitle":"Interpreter","url":"interpreter#basic-usage","content":"Joern can be used in non-interactive mode. You would execute commands and operations via a script that you specify as an argument instead of manually typing them after the Joern prompt. Joern runs the commands in your script and exits when done. For example, let's say you have a file named test.sc with the following contents: @main def exec(cpgFile: String, outFile: String) = { loadCpg(cpgFile) cpg.method.name.l |> outFile } Copy You can include Scala code in test.sc and use the |> operator to pipe output into files. The script is then run as follows: ./joern --script test.sc --params cpgFile=/src.path.zip,outFile=output.log Copy "},{"title":"Importing Additional Scripts","type":1,"pageTitle":"Interpreter","url":"interpreter#importing-additional-scripts","content":"If your script depends on code from one or more additional scripts, you can use the --import parameter, which accepts a comma-separated list of input scripts: ./joern --script test.sc --params cpgFile=/src.path.zip,outFile=output.log --import scripts/hello.sc Copy "},{"title":"Workspace","type":0,"sectionRef":"#","url":"organizing-projects","content":"","keywords":""},{"title":"The Workspace","type":1,"pageTitle":"Workspace","url":"organizing-projects#the-workspace","content":"The Workspace is a directory on your file system in which all files generated during analyses are saved. Every Joern installation has exactly one Workspace and it provides access to it with the workspace command. Type workspace in your Joern Shell now and press ENTER to evaluate: joern> workspace The workpace is empty. Use `importCode` or `importCpg` to populate it res0: io.shiftleft.console.workspacehandling.WorkspaceManager[io.shiftleft.repl.JoernProject] = empty Copy The Joern Workspace will be empty if you haven't used Joern before. While empty, it's not of much use, but you can still print its path on the filesystem using the workspace.getPath method: joern> workspace.getPath res1: String = \"/home/user/.shiftleft/joern/workspace\" Copy OK. You now know what the Workspace is, and where it is located, let us move on to something more exciting, Joern Projects. "},{"title":"Joern Projects","type":1,"pageTitle":"Workspace","url":"organizing-projects#joern-projects","content":"An Joern Project is a collection of files related to a single analysis. Just like the Joern Workspace, Joern Projects are represented by directories on your filesystem. Each project directory contains the project metadata (like its name, or the absolute path of the program under analysis), a binary representation of the Code Property Graph for the program under analysis, and, optionally, binary representations of the Code Property Graph Overlays that have been generated. Other files may be part of project directories, but we will leave their description for later. For now, let us create two Joern Projects using the importCode top-level command of the Joern Shell. importCode does four things: 1) it creates a new Joern Project for a program found at a path, 2) it generates a Code Property Graph for that program, 3) it loads the generated Code Property Graph into memory, and 4) it generates Code Property Graph Overlays for that Code Property Graph. For the purposes of this demonstration, you will create the two Joern Projects from a sample program named X42. Clone the following git repository which contains its implementation in a few different programming languages: $ git clone git@github.com:ShiftLeftSecurity/x42.git Copy Now run importCode, first for the C implementation of the X42 program: joern> importCode(\"./x42/c\", \"x42-c\") Creating project `x42-c` for code at `./x42/c` // ...output trimmed res1: Option[Cpg] = Some(io.shiftleft.codepropertygraph.Cpg@7923e12c) Copy note If you see an error and a return value of None, you have probably pointed Joern to the wrong input path for the directory containing the source code for the sample project. Ensure it is correct by navigating to the git repository you cloned and using its absolute path in the importCode command. Then, for the Java implementation of the same X42 program: joern> importCode(\"./x42/java/X42.jar\", \"x42-java\") Creating project `x42-java` for code at `./x42/java/X42.jar` // ...output trimmed res2: Option[Cpg] = Some(io.shiftleft.codepropertygraph.Cpg@5d41bf70) Copy If you did everything right, the output of workspace will look something like this: joern> workspace res3: io.shiftleft.console.workspacehandling.WorkspaceManager[io.shiftleft.repl.JoernProject] = ____________________________________________________________________________ | name | overlays | inputPath | open| |==========================================================================| | x42-java| semanticcpg,dataflow,tagging| /home/user/x42/java/X42.jar| true| | x42-c | semanticcpg,dataflow,tagging| /home/user/x42/c | true| Copy The output is fairly self-explanatory. The Joern Workspace contains two Joern Projects, one named x42-c and one named x42-java. The second column, overlays, lists the Code Property Graph Overlays that have been created for each project. Values in the inputPath column refer to the absolute filesystem paths of the programs these projects represent. And finally, open specifies whether the Code Property Graphs are currently loaded in memory. note You might have noticed that the paths pointing to the different language implementations of the X42 program differ slightly. One points to a directory, another to a file. That is because of the way Joern creates Code Property Graphs for programs. For Java, JAR files are supported. For other languages, directories with source files. Each Joern Shell session has one active project at a time, and you can find out which one it is using the project command: joern> project res4: io.shiftleft.repl.JoernProject = Project( ProjectFile(\"/home/user/x42/c\", \"x42-c\"), /home/user/.shiftleft/joern/workspace/x42-c, Some(io.shiftleft.codepropertygraph.Cpg@28ce038d) ) Copy The active project is the project which contains the Code Property Graph you want to focus your analysis on at a given time. Some important Joern Shell commands always refer to the current active project. For example, if you run cpg.metaData.l, the return value will be the META_DATA node of the Code Property Graph of the currently active project, which in this case, is x42-c: joern> cpg.metaData.l res5: List[MetaData] = List( MetaData( id -> 2L, language -> \"C\", version -> null, overlays -> List(\"semanticcpg\", \"dataflow\", \"tagging\"), policyDirectories -> List(), spid -> None ) ) Copy If instead you'd like access to the META_DATA node of the x42-java project, you'd first make it the active project using workspace.setActiveProject: joern> workspace.setActiveProject(\"x42-java\") res6: Option[io.shiftleft.repl.JoernProject] = Some( Project( ProjectFile(\"/home/user/x42/java/X42.jar\", \"x42-java\"), /home/user/.shiftleft/joern/workspace/x42-java, Some(io.shiftleft.codepropertygraph.Cpg@13a6e76f) ) ) Copy And then run the cpg.metaData.l command again to see its META_DATA node: joern> cpg.metaData.l res7: List[MetaData] = List( MetaData( id -> 1L, language -> \"JAVA\", version -> \"0.1\", overlays -> List(\"semanticcpg\", \"dataflow\", \"tagging\"), policyDirectories -> List(), spid -> None ) ) Copy Other top-level commands that refer to the currently active project are run, open, close, delete and undo. That concludes this gentle introducton into the commands the Joern Shell provides you with for organizing your Joern Projects. Have fun with your analysis! "},{"title":"Quickstart","type":0,"sectionRef":"#","url":"quickstart","content":"","keywords":""},{"title":"Obtaining the Sample Program","type":1,"pageTitle":"Quickstart","url":"quickstart#obtaining-the-sample-program","content":"Before you start Joern, you should have a program ready to analyze. Clone the following git repository which contains a simple program named X42: $ git clone git@github.com:ShiftLeftSecurity/x42.git Copy Let us start with a problem statement. Show - without running the program - that an input exists for which X42 writes a string to standard error (STDERR). // X42.c #include <stdio.h> #include <stdlib.h> #include <string.h> int main(int argc, char *argv[]) { if (argc > 1 && strcmp(argv[1], \"42\") == 0) { fprintf(stderr, \"It depends!\\n\"); exit(42); } printf(\"What is the meaning of life?\\n\"); exit(0); } Copy "},{"title":"Starting Joern's Interactive Shell","type":1,"pageTitle":"Quickstart","url":"quickstart#starting-joerns-interactive-shell","content":"Launch Joern in your shell: $ joern Copy A console session will start and you will see a prompt: joern> Copy The prompt you are looking at is the prompt of a Scala-based REPL. If you have no experience with Scala or read-eval-print-loops, don't worry, you can accomplish a lot with Joern by focusing only on what its commands allow you to do. If you are familiar with Scala and REPLs, you may be pleasantly surprised at the flexibility it provides you with. "},{"title":"Importing the Code","type":1,"pageTitle":"Quickstart","url":"quickstart#importing-the-code","content":"We create a Code Property Graph for the X42 program using the command importCode, which requires the path to the source code to be passed as a first argument, and a project name as a second argument. In particular, importCode creates a new project directory and stores a binary representation of the Code Property Graph in it. joern> importCode(inputPath=\"./x42/c\", projectName=\"x42-c\") Creating project `x42-c` for code at `x42/c` ... output omitted res1: Option[Cpg] = Some(io.shiftleft.codepropertygraph.Cpg@31ed46c5) Copy note If you see an error and a return value of None, you have probably pointed Joern to the wrong input path for the directory containing the source code for the sample project. "},{"title":"Querying the Code Property Graph","type":1,"pageTitle":"Quickstart","url":"quickstart#querying-the-code-property-graph","content":"You are ready to analyze your first program using Joern and the Code Property Graph. Code analysis in Joern is done using the query language, a domain-specific language designed specifically for work with the Code Property Graph. It contains practical representations of the various nodes found in the Code Property Graph, and useful functions for querying their properties and relationships between each other. The top-level entry point into a Code Property Graph loaded in memory, and the root object of the query Language is cpg. If you evaluate cpg at the prompt, the output is underwhelming: joern> cpg res2: Cpg = io.shiftleft.codepropertygraph.Cpg@cb0d5241 Copy Rest assured, a lot is hidden behind that simple statement. You will discover the full set of commands in time, but for now, you should learn a helpful Joern trick: TAB-completion. In the Joern prompt, type cpg., do not press ENTER, but instead press TAB. You will see a list of available functions cpg supports: joern> cpg. all comment finding local newArgumentDescriptorSource newReturnSource runScript types annotation configfile flow member newArgumentSink newTagForMethodsWithFullName scalaGraph write argument cpg graph metaData newArgumentSource newTagForParameter sensitiveType arithmetic dependency help method newExposedParameterSink newTagForParameterWithIndex sensitiveVariable assignment dom id methodRef newExposedParameterSource newTagForParameterWithIndexes sink blacklist exposedMethod identifier methodReturn newLiteralSource packagePrefix source call exposedOutputParameter ioFlow namespace newMethodSummary parameter tag callChain exposedParameter jsp namespaceBlock newReturnDescriptorSource read transform close file literal newArgumentDescriptorSink newReturnSink returns typeDecl Copy TAB-completion is available for all query language directives, and for top-level commands. For more descriptive assistance, use the helpcommand, like so: joern> help.cpg res3: String = \"\"\" Upon importing code, a project is created that holds an intermediate representation called `Code Property Graph`. This graph is a composition of low-level program representations such as abstract syntax trees and control flow graphs, but it can be arbitrarily extended to hold any information relevant in your audit, information about HTTP entry points, IO routines, information flows, or locations of vulnerable code. Think of Joern as a CPG editor. In practice, `cpg` is the root object of the query language, that is, all query language constructs can be invoked starting from `cpg`. For exanple, `cpg.method.l` lists all methods, while `cpg.finding.l` lists all findings of potentially vulnerable code.\"\"\" Copy "},{"title":"Solving the Challenge","type":1,"pageTitle":"Quickstart","url":"quickstart#solving-the-challenge","content":"Now that we have a good set of basic commands, and a Code Property Graph loaded in memory, let us return to our X42 program and the problem we want to solve using Joern. To reiterate, the problem statement is Show that an input exists for which the X42 program always writes a string to STDERR. And this is the X42 program: // X42.c #include <stdio.h> #include <stdlib.h> #include <string.h> int main(int argc, char *argv[]) { if (argc > 1 && strcmp(argv[1], \"42\") == 0) { fprintf(stderr, \"It depends!\\n\"); exit(42); } printf(\"What is the meaning of life?\\n\"); exit(0); } Copy There are two parts in the problem statement: 1. does the program write anything to STDERR?, and 2. _if there is a call writing to STDERR, is it conditional on a value passed in as argument to theX42 program? Joern makes answering both questions easy. To answer the first one, whether the program writes anything to STDERR, we can search for nodes of type CALL in the graph, then use the argument step to only select those calls which have connections to nodes of type ARGUMENT, followed by the code(\"stderr\") property filter step which selects only those nodes that have the string stderr as the value of their CODEproperty. We find exactly one: joern> cpg.call.argument.code(\"stderr\").toList res4: List[Call] = List( Call( id -> 24L, code -> \"fprintf(stderr, \\\"It depends!\\\\n\\\")\", name -> \"fprintf\", order -> 1, methodInstFullName -> None, methodFullName -> \"fprintf\", argumentIndex -> 1, dispatchType -> \"STATIC_DISPATCH\", signature -> \"TODO assignment signature\", typeFullName -> \"ANY\", dynamicTypeHintFullName -> List(), lineNumber -> Some(7), columnNumber -> Some(4), resolved -> None, depthFirstOrder -> Some(-8), internalFlags -> Some(4) ) ) Copy With this query we have proven the first part of our problem statement correct, there is a place in the X42 program that writes to STDERR. Let us move to the second part, the check whether the call that writes something to STDERR is conditional on a value passed as input to the X42 program. Since we are analyzing a program written in C, we will search the Code Property Graph for the conventional argc or argv parameters of the main function as the input that potentially triggers the call which writes to STDERR. Using the query from the previous step, we can use the astParent construct to find out more about the surroundings around the fprintf call by moving up in the hierarchy of the abstract syntax tree that is part of the Code Property Graph. Moving up one level in the AST hierarchy gives us a block; not very helpful: joern> cpg.call.argument.code(\"stderr\").astParent.toList res5: List[AstNode] = List( Block( id -> 23L, code -> \"\", order -> 2, argumentIndex -> 2, typeFullName -> \"void\", dynamicTypeHintFullName -> List(), lineNumber -> Some(6), columnNumber -> Some(46), depthFirstOrder -> Some(-24), internalFlags -> Some(0) ) ) Copy Another two layers up gives us an if statement, much better: joern> cpg.call.argument.code(\"stderr\").astParent.astParent.astParent.l res6: List[AstNode] = List( ControlStructure( id -> 11L, code -> \"if (argc > 1 && strcmp(argv[1], \\\"42\\\") == 0)\", columnNumber -> Some(2), lineNumber -> Some(6), order -> 1, parserTypeName -> \"IfStatement\", argumentIndex -> 1, depthFirstOrder -> None, internalFlags -> None ) ) Copy The CODE property of the CONTROL_STRUCTURE node you just found proves the second part of our problem statement correct, the call that writes to STDERR is conditional on argc and argv. Hence, the whole problem statement is correct. "},{"title":"Closing the Project","type":1,"pageTitle":"Quickstart","url":"quickstart#closing-the-project","content":"Now that we've finished the analysis, let us close the project, which also unloads the Code Property Graph from memory. You do not have to worry about losing any data, because it will remain on disk in the x42-c project you created earlier with importCode. Close the project using the aptly-named close: joern> close 2020-05-08 01:13:01.752 WARN clearing 105 references - this may take some time 2020-05-08 01:13:01.756 WARN cleared all clearable references res7: Option[io.shiftleft.console.workspacehandling.Project] = Some( Project( ProjectFile(\"/home/user/x42/c\", \"x42-c\"), /home/user/.shiftleft/joern/workspace/x42-c, None ) ) Copy As a final step, exit Joern: joern> exit Bye! Would you like to save changes? (y/N) y saving. Copy Congratulations, you have succesfully queried your first Code Property Graph using Joern and its query language. In subsequent articles, you will learn the more advanced features of Joern and also how to use it to find your first real-world vulnerability. "},{"title":"Server","type":0,"sectionRef":"#","url":"server","content":"","keywords":""},{"title":"For Developers","type":1,"pageTitle":"Server","url":"server#for-developers","content":"If you are interested in querying Code Property Graphs from your favorite programming language and that language is not JVM-based and not Python, then the following information on the server's API may be of interest to you. The HTTP API allows posting queries and obtaining responses. Additionally, a Websocket is offered that clients can subscribe to in order to be notified by the server when query responses are available. This will spawn a web server on port 8080 with the following functionality: Route\tDescription\tMethod\tPOST Body\tResponse Body/query\tSubmit query\tPOST\t{\"query\": $query}\t{\"uuid\": \"$uuid\"} /result?uuid=$uuid\tRetrieve response\tGET\t-\t{\"success\": \"{true, false}\", \"stdout\": \"$stdout\", \"stderr\" : \"$stderr\"} where $query is the query to be executed, $uuid is an id assigned to the query by the server upon receipt, and $stdout and $stderris the data written by the interpreter to standard output and standard error respectively in response to the query. If a response for a query is not yet available, the response body is of the form {\"success\" : \"false\", ...} and the client is expected to ask for the response at a later point in time. For interactive use cases, this polling approach may be problematic. In this case, the client can subscribe to a Websocket offered via ws://$hostname:8080/connect Copy where $hostname is the name of the host on which the server is running. Once subscribed, uuids of completed queries are reported on the web socket. note Note that the server exclusively implements remote access to an interpreter, it does not implement sandboxing. As such, it is not to be considered a security boundary and sandboxing must be achieved via other means in production environments. "},{"title":"Interactive Shell","type":0,"sectionRef":"#","url":"shell","content":"","keywords":""},{"title":"Launching the Interactive Shell","type":1,"pageTitle":"Interactive Shell","url":"shell#launching-the-interactive-shell","content":"The shell can be started by issuing the following command: $ joern Copy "},{"title":"Basic Keyboard Commands","type":1,"pageTitle":"Interactive Shell","url":"shell#basic-keyboard-commands","content":"The Joern underlying shell is essentially an interactive Scala shell that supports the following keyboard commands: Command\tDescriptionCTRL-c\tCancels current operation/clears shell. Does not quit Joern CTRL-d\tQuits Joern (shell must be clear) TAB\tAutocomplete UP\tMoves through command history CTRL-LEFT/RIGHT\tStep through commands word-by-word (instead of character-by-character) CTRL-r\tSearches command history. Use CTRL-r (or UP/DOWN) to cycle through your matches "},{"title":"Exporting Results with Pipe Operators and toJson","type":1,"pageTitle":"Interactive Shell","url":"shell#exporting-results-with-pipe-operators-and-tojson","content":"The execution directive (see Traversal Basics) toJson can be used at the end of queries in order to convert results into the JSON format. This feature can be combined with the shell's pipe operators to write results out to the file system. For example, cpg.method.toJson |> \"/tmp/foo.json\" Copy writes all methods nodes into the file /tmp/foo.json. "},{"title":"Inline Code Browsing","type":1,"pageTitle":"Interactive Shell","url":"shell#inline-code-browsing","content":"For an increasing number of languages, the Joern shell allows you to read code associated with query results directly on the shell. For example, to review all calls to memcpy, you can issue: joern> cpg.method.name(\"memcpy\").callIn.code.l res5: List[String] = List( \"memcpy(buf, first, first_len)\", \"memcpy(buf + first_len, second, second_len)\", \"memcpy(buf, first, first_len)\", \"memcpy(buf + first_len, second, second_len)\", \"memcpy(buf + first_len, second, second_len)\", \"memcpy(buf, first, first_len)\" ) Copy You can also pipe the result list into a pager as follows: joern> browse(cpg.method.name(\"memcpy\").callIn.code.l) Copy To study the context in which a result occurs, you can use the .dump method, which will dump the enclosing function’s code for each finding, and point you to the finding via an arrow: joern> cpg.method.name(\"memcpy\").callIn.dump int main() { unsigned int first_len = UINT_MAX - 256; unsigned int second_len = 256; unsigned int buf_len = 256; char first[first_len], second[second_len], buf[buf_len]; int new_len = (first_len+second_len); // <- IDB (negative) if(new_len <= 256) { memcpy(buf, first, first_len); memcpy(buf + first_len, second, second_len); /* <=== */ } } ... Copy You can use this feature together with browse to read code in the pager. Finally, if you want to read the code in your editor of choice, just dump it to a file: cpg.method.name(\"memcpy\").callIn.dumpRaw |> \"/tmp/foo.c\" Copy We use dumpRaw here to skip syntax highlighting, as your editor will most likely do that for you. note Please make suresource-highlight is installed for the .dump feature to work. "},{"title":"Dynamically Importing Additional Scripts","type":1,"pageTitle":"Interactive Shell","url":"shell#dynamically-importing-additional-scripts","content":"You can dynamically load additional scripts at any time. As an example, let's assume there's a file called MyScript.sc that contains only val elite = 31337. You can import the script as follows: import $file.MyScript MyScript.elite res1: Int = 31337 Copy If the file is in a subfolder (e.g. scripts), use dot syntax: import $file.scripts.MyScript. To go up one directory, use ^. "},{"title":"Adding Dependencies to the JVM classpath Dynamically","type":1,"pageTitle":"Interactive Shell","url":"shell#adding-dependencies-to-the-jvm-classpath-dynamically","content":"// java dependency import $ivy.`com.michaelpollmeier:versionsort:1.0.1` versionsort.VersionHelper.compare(\"2.1.0\", \"2.0.10\") // res: Int = 1 // scala dependency import $ivy.`com.michaelpollmeier::colordiff:0.9` colordiff.ColorDiff(List(\"a\", \"b\"), List(\"a\", \"bb\")) // color coded diff Copy If the dependencies are not on Maven Central, you can add a resolver: interp.repositories() ++= Seq(coursierapi.MavenRepository.of(\"https://shiftleft.jfrog.io/shiftleft/libs-snapshot-local\")) Copy "},{"title":"Measuring the Time While Running a Computation","type":1,"pageTitle":"Interactive Shell","url":"shell#measuring-the-time-while-running-a-computation","content":"time { println(\"long running computation\") Thread.sleep(1000) 42 } // res: (42, 1000332390 nanoseconds) Copy "},{"title":"Upgrade guides","type":0,"sectionRef":"#","url":"upgrade-guides","content":"","keywords":""},{"title":"1.1.1: OverflowDb Traversals","type":1,"pageTitle":"Upgrade guides","url":"upgrade-guides#111-overflowdb-traversals","content":"This release introduces a major rearchitecture of the cpg query language (CPGQL). Most changes happened under the hood, however there are a few changes that are user facing. The migration should be straightforward, and in any case we're here to help. Background: CPGQL was previously based on the Gremlin graph traversal language (accessible via .raw), and is now based on OverflowDb Traversal. The main drivers behind this change are: better performance, less complexity and fewer dependencies. OverflowDb Traversal is a Scala collection with additional graph steps, which means we now inherit many useful steps from the rich Scala standard collection library, where previously convertions between Traversal and Scala collections were needed. At the same time, Traversal offers largely the same steps and semantics as its TinkerPop predecessor. Here are the most important new parts - from our experience the swap of filter and where accounts for 90% of user-facing changes: filter(A => Boolean): just like any other Scala collection, filter now simply takes a predicate (it used to take a Traversal). where(trav: Traversal[A] => Traversal[_]): preserves elements if the provided traversal has at least one result. This is what filter used to be.Effectively, filter and where are swapped. RIP filterOnEnd - this is now simply filter repeat now has a builder DSL to configure it's behaviour, which is more specific and easier to understand than tinkerpop's api, which relied on the order of modulators in the traversal. For example, in tinkerpop .emit.repeat(Traversal) means \"emit everything\", while .repeat(Traversal).emit means \"emit all but the first element\". In OverflowDb Traversal this behaviour is more explicit: .repeat(Traversal)(_.emit) and .repeat(Traversal)(_.emitAllButFirst). Some more examples for the migration: .repeat(x).until(y) -> .repeat(x)(_.until(y)).emit.repeat(x) -> .repeat(x)(_.emit).repeat(x).emit -> .repeat(x)(_.emitAllButFirst).emit.repeat(x).times(2) -> .repeat(x)(_.emit.times(2)) repeat uses depth first search (DFS) by default and can be configured to use breadth first search (BFS) instead. Tinkerpop has a long standing issue that it claims to use DFS but actually uses BFS, and also cannot be configured to use one or the other. .start step only exists for Node and NewNode, not for other collections any more. Instead, use the standard scala collection mechanism .to(Traversal): // still works - nothing changed: val someMethod = cpg.method.head someMethod.start.parameter //Traversal[MethodParameterIn] // using `.to(Traversal)` - standard scala collection mechanism val methodList: cpg.method.l methodList.to(Traversal) //Traversal[Method] Copy .clone doesn't exist any more - note that Traversals typically have Iterator semantics, i.e. they are consumed during iteration: val source = cpg.identifier.name(\"foo\") val sink = cpg.call.name(\"bar\") sink.reachableByFlows(source).l //contains flows (if any) sink.reachableByFlows(source).l //always empty - both source and sink Traversals have been consumed! Copy If you want to execute your traversals multiple times, simply define them as a function (def) rather than a value (val): def source = cpg.identifier.name(\"foo\") def sink = cpg.call.name(\"bar\") sink.reachableByFlows(source).l //contains flows (if any) sink.reachableByFlows(source).l //same result: also contains flows (if any) Copy Please let us know if you need help with your migration, either by opening an issue or asking on gitter. "},{"title":"Bleeding edge / power users only:","type":1,"pageTitle":"Upgrade guides","url":"upgrade-guides#bleeding-edge--power-users-only","content":"8) If you used the underlying tinkerpop api and OverflowDb types (e.g. via .raw), your scripts may be subject to additional changes, due to the removal of the Tinkerpop dependency and renames in OverflowDb types: Steps -> TraversalNodeSteps -> TraversalNewNodeSteps -> TraversalOdbGraph -> GraphOdbNode -> NodeDbOdbEdge -> Edgeid2 -> idgraph2 -> graphaddEdge2 -> addEdgesetProperty2 -> setPropertyNodeKeysOdb -> NodeKeysall Tinkerpop types are gone: Vertex, Edge, VertexProperty, ScalaGraph, GremlinScala, ... "},{"title":"Traversal Basics","type":0,"sectionRef":"#","url":"traversal-basics","content":"","keywords":""},{"title":"The Anatomy of an Joern Query","type":1,"pageTitle":"Traversal Basics","url":"traversal-basics#the-anatomy-of-an-joern-query","content":"A query consists of the following components: A Root Object, which is the reference to the Code Property Graph being queriedZero or more Node-Type Steps, which are atomic traversals to all nodes of a given typeZero or more Filter Steps, Map Steps or Repeat StepsZero or more Property Directives, which reference the properties of nodes in a traversalZero or more Execution Directives, which execute a traversal and return results in a specific formatZero or more Augmentation Directives, which extend a Code Property Graph with new nodes, properties, or edges Finally, components 2-7 can be combined into Complex Steps in the same way basic expressions of a programming language can be combined into complex expressions. As an example, the query cpg.method.name.toList Copy returns all names of methods present in a Code Property Graph and can be dissected as follows: cpg is the root object, method is a node-type step which references all METHOD nodes, name is a property directive which references the NAME property of those METHOD nodes, and toList is an execution directive which executes the traversal and returns the result as a list. "},{"title":"Importing a Sample Project","type":1,"pageTitle":"Traversal Basics","url":"traversal-basics#importing-a-sample-project","content":"Before we go into the details of these components, let us import a sample program. Clone the following git repository which contains the Java implementation of a simple program named X42: $ git clone git@github.com:ShiftLeftSecurity/x42.git Copy Start Joern and specify a 4GB JVM heap size using the JAVA_OPTS environment variable: $ JAVA_OPTS='-Xmx4g' joern Copy Then create a Project from the JAR file of the X42 program using the importCode top-level command: joern> importCode(\"./x42/c/\", \"x42\") Creating project `x42` for code at `x42/c/` ... output omitted res0: Option[Cpg] = Some(io.shiftleft.codepropertygraph.Cpg@31ed46c5) Copy "},{"title":"A First Traversal","type":1,"pageTitle":"Traversal Basics","url":"traversal-basics#a-first-traversal","content":"For our first traversal, our objective is to determine the LANGUAGE property of the METADATA node in the Code Property Graph of the X42 program. At the Joern prompt, type cpg and press ENTER: joern> cpg res1: Cpg = io.shiftleft.codepropertygraph.Cpg@ab90fdab Copy The executed query consists only of the root object cpg. The return value of that execution is a reference to the Code Property Graph and the reference itself is suffixed by a hexadecimal string (in this case @ab90fdab) that uniquely identifies it. We proceed to add the metaData node-type step to the query. This step represents a traversal to all nodes of type METADATA (of which there is only one): joern> cpg.metaData res2: Traversal[MetaData] = Traversal Copy Note that the result is not the content of the METADATA node, but a traversal that visits the METADATA node. In other words, Traversals are lazyly evaluated - you can compose them and at some later point execute them, as we will see. This behaviour points to the ephemeral nature of queries: each query is separate from the other, and Joern holds distinct in-memory representations for them. The only object shared between queries is the root object (cpg). Traversals are executed - as opposed to just to being held in memory - using execution directives such as toList. The directive toList executes the traversal and returns results in a list: joern> cpg.metaData.toList res3: List[MetaData] = List( MetaData( id -> 1L, language -> \"C\", version -> \"0.1\", overlays -> List(\"semanticcpg\"), policyDirectories -> List(), spid -> None ) ) Copy In the result of this query, we already see the LANGUAGE field and that it is C. For the sake of completeness and to illustrate property directives, let us add the property directive language to the query. Property directives provide access to individual node properties. Each node-type step can be combined with different property directives, and they usually match the properties defined on the node type represented by the node-type step: joern> cpg.metaData.language.toList res4: List[AnyRef] = \"C\" Copy With this last query, we have achieved our goal of executing a traversal which returns the LANGUAGE property of the METADATA node of the X42 program. "},{"title":"Node-Type Steps","type":1,"pageTitle":"Traversal Basics","url":"traversal-basics#node-type-steps","content":"Node-Type Steps are atomic traversals that represent traversals to nodes of a given type. Each node-type step comes with distinct Property Directives to access the properties of the nodes they represent. Let us revisit the source code of the x42 program to illustrate node-type steps. // X42.c #include <stdio.h> #include <stdlib.h> #include <string.h> int main(int argc, char *argv[]) { if (argc > 1 && strcmp(argv[1], \"42\") == 0) { fprintf(stderr, \"It depends!\\n\"); exit(42); } printf(\"What is the meaning of life?\\n\"); exit(0); } Copy A commonly used node-type step is method, which represents a traversal to all nodes of type METHOD. METHOD nodes represent declarations of methods, functions or procedures in programs, and one of their properties is NAME. All names of all method nodes can thus be determined as follows: joern > cpg.method.name.l res4: List[String] = List( \"<operator>.logicalAnd\", \"strcmp\", \"<operator>.equals\", \"printf\", \"fprintf\", \"exit\", \"<operator>.greaterThan\", \"main\", \"<operator>.indirectIndexAccess\" ) Copy The number of METHOD nodes may surprise you, given that the program only defines the single method main explicitly. The Code Property Graph, however, also includes method nodes for all methods invoked by the code. Moreover, built-in operators are modeled as methods, one decision made to enable language-agnostic analysis. We will look into the details of node-type steps in a different article. For now, it is sufficient to know that Joern offers these steps for all common node types: method, call, argument, parameter, metaData, local, literal, types, returns, identifier, namespace, namespaceBlock, methodReturn, typeDecl, member, methodRef, file, comment, tag and the generic all. "},{"title":"Filter Steps","type":1,"pageTitle":"Traversal Basics","url":"traversal-basics#filter-steps","content":"Filter Steps are atomic traversals that filter nodes according to given criteria. The most common filter step is aptly-named filter, which continues the traversal in the step it suffixes for all nodes which pass its criterion. Its criterion is represented by a lamba function which has access to the node of the previous step and returns a boolean. Continuing with the previous example, let us execute a query which returns all METHOD nodes of the Code Property Graph for X42, but only if their IS_EXTERNAL property is set to false: joern> cpg.method.filter(_.isExternal == false).name.toList res11: List[String] = List(\"main\") Copy Disecting this query, we have cpg as the root object, a node-type step method which returns all nodes of type METHOD, a filter step where(_.isExternal == false) which continues the traversal only for nodes which have their IS_EXTERNAL property set to false (with _ referencing the individual nodes, and isExternal a property directive which accesses their IS_EXTERNAL property), followed by a property directive name which returns the values of the NAME property of the nodes that passed the Filter Step, and finally an Execution Directive toList which executes the traversal and returns the results in a list. A shorter version of a query which returns the same results as the one above can be written using a Property-Filter Step. Property-filter steps are Filter Steps which continue the traversal only for nodes which have a specific value in the property the Property Filter Step refers to: joern> cpg.method.isExternal(false).name.toList res11: List[String] = List(\"main\") Copy Disecting the query again, cpg is the root object, method is a node-type step, isExternal(false) is a property-filter step that filters for nodes which have false as the value of their IS_EXTERNAL property, name is a property directive, and toList is the execution directive you are already familiar with. note Be careful not to mix up property directives with property-filter steps, they look awfully similar. Consider that: a) cpg.method.isExternal(true).name.toList returns all METHOD nodes which have the IS_EXTERNAL property set to true (in this case, 10 results) b) cpg.method.isExternal.toList returns the value of the IS_EXTERNAL property for all METHOD nodes in the graph (12 results) c) cpg.method.isExternal.name.toList is an invalid query which will not execute A final Filter Step we will look at is named where. Unlike filter, this doesn't take a simple predicate A => Boolean, but instead takes a Traversal[A] => Traversal[_]. I.e. you supply a traversal which will be executed at the current position. The resulting Traversal will preserves elements if the provided traversal has at least one result. The previous query that used a Property Filter Step can be re-written using where like so: joern> cpg.method.where(_.isExternal(false)).name.toList res24: List[String] = List(\"main\") Copy Maybe not particulary useful-seeming given this specific example, but keep it in the back of your head, because filter is a handy tool to have in the toolbox. Next up, Map Steps. "},{"title":"Map Steps","type":1,"pageTitle":"Traversal Basics","url":"traversal-basics#map-steps","content":"Map Steps are traversals that map a set of nodes into a different form given a function. Map Steps are a powerful mechanism when you need to transform results to fit your specifics. For example, say you'd like to return both the IS_EXTERNAL and the NAME properties of all METHOD nodes in X42's Code Property Graph. You can achieve that with the following query: joern> cpg.method.map(node => (node.isExternal, node.name)).toList res6: List[(java.lang.Boolean, String)] = List( (true, \"<operator>.logicalAnd\"), (true, \"strcmp\"), (true, \"<operator>.equals\"), (true, \"printf\"), (true, \"fprintf\"), (true, \"exit\"), (true, \"<operator>.greaterThan\"), (false, \"main\"), (true, \"<operator>.indirectIndexAccess\") ) Copy Don't be intimidated by the syntax used in the map Step above. If you examine map(node => (node.isExternal, node.name)) for a bit, you might be able to infer that the first node simply defines the variable that represents the node which preceeds the map Step, that the ASCII arrow => is just syntax that preceeds the body of a lambda function, and that (node.isExternal, node.name) means that the return value of the lambda is a list which contains the value of the isExternal and name Property Directives for each of the nodes matched in the previous step and also passed into the lambda. In most cases in which you need map, you can simply follow the pattern above. But should you ever feel constrained by the common pattern shown, remember that the function for the map step is written in the Scala programming language, a fact which opens up a wide range of possibilities if you invest a little time learning the language. "},{"title":"Complex Steps","type":1,"pageTitle":"Traversal Basics","url":"traversal-basics#complex-steps","content":"Another useful Joern Query Component is the Complex Step. Complex Steps combine many simpler steps into one in order to make your queries more concise. There are a number of them available, all with different behaviours, and one good example is isConstructor. Before we use it in a query, here is the X42 program again: // X42.c #include <stdio.h> #include <stdlib.h> #include <string.h> int main(int argc, char *argv[]) { if (argc > 1 && strcmp(argv[1], \"42\") == 0) { fprintf(stderr, \"It depends!\\n\"); exit(42); } printf(\"What is the meaning of life?\\n\"); exit(0); } Copy Earlier we queried it for all METHOD nodes which had their IS_EXTERNAL property set to false using the isExternal(false) Property Filter Step. Two results came up, even though only one method is explicitly defined: joern> cpg.method.isExternal(false).name.l res103: List[String] = List(\"main\") Copy Two useful Complex Steps are astParent and astChildren, which allow you to steer your traversals through the abstract syntax tree of the program under analysis. Say you'd like to have a query that returns the CODE property for all nodes of type LITERAL which are AST child nodes of CALL nodes that have println in their NAME property: joern> cpg.call.name(\"println\").astChildren.isLiteral.code.l res87: List[String] = List(\"\\\"What is the meaning of life?\\\"\", \"\\\"It depends!\\\"\") Copy Or taken the other way around, a query which returns the property of all CALL nodes which have AST parent nodes of type LITERAL that have their CODE property set to \\\"What is the meaning of life?\\\": joern> cpg.literal.filter(_.code == \"\\\"What is the meaning of life?\\\\n\\\"\").astParent.isCall.name.toList res100: List[String] = List(\"println\") Copy Describing queries in human language tends to sound peculiar. But so would descriptions of bash one-liners, or basic regular expressions if you'd try out that exercise. As long as you understand the individual components of a query, it won't be hard to construct them correctly and understand clearly what they do. One final Joern Query Component we'll examine in this article is the Repeat Step. "},{"title":"Repeat Steps","type":1,"pageTitle":"Traversal Basics","url":"traversal-basics#repeat-steps","content":"There are cases in which queries have repetitions in them and become too long. In order to make them more readable, you can use Repeat Steps. Repeat Steps are traversals that repeat other traversals a number of times. For example, say you'd like to find nodes of type LITERAL in X42's Code Property Graph that are directly reachable from the node which represents the main method. One way of doing that is by using five astChildren Complex Steps in combination with isLiteral, which is another Complex Step that filters for AST nodes of type LITERAL and maps them to actual LITERAL nodes, plus the code(\"42\") Property Filter Step: joern> cpg.method.name(\"main\").astChildren.astChildren.astChildren.astChildren.astChildren.isLiteral.code(\"42\").toList res137: List[Literal] = List( Literal( id -> 1000000050L, code -> \"42\", order -> 1, argumentIndex -> 1, typeFullName -> \"int\", dynamicTypeHintFullName -> List(), lineNumber -> Some(5), columnNumber -> None, depthFirstOrder -> None, internalFlags -> None ) ) Copy The query might do the job, but it is hard to read and change. repeat-times makes the query clearer: joern> cpg.method.name(\"main\").repeat(_.astChildren)(_.times(5)).isLiteral.code(\"42\").l res138: List[Literal] = List( Literal( id -> 1000000050L, code -> \"42\", order -> 1, argumentIndex -> 1, typeFullName -> \"int\", dynamicTypeHintFullName -> List(), lineNumber -> Some(5), columnNumber -> None, depthFirstOrder -> None, internalFlags -> None ) ) Copy And even better is another variant of repeat, namely repeat-until: joern> cpg.method.name(\"main\").repeat(_.astChildren)(_.until(_.isLiteral.code(\"42\"))).l res139: List[AstNode] = List( Literal( id -> 1000000050L, code -> \"42\", order -> 1, argumentIndex -> 1, typeFullName -> \"int\", dynamicTypeHintFullName -> List(), lineNumber -> Some(5), columnNumber -> None, depthFirstOrder -> None, internalFlags -> None ) ) Copy We won't go any further in this article. If you've read so far, you already have a good overview of the most important Joern Query Components. And while the examples you've seen focused on the simple X42 program, rest assured, queries that find serious vulnerabilities in programs with millions of lines of code are not much different. Master these basics and you will already have found a strong tool in your code analysis arsenal. As soon as you feel ready, explore the more advanced walkthroughs for a level-up. Have fun! "}]